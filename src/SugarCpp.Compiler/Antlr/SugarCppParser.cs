//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 SugarCpp.g 2013-04-28 23:10:09

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System;
	using System.Collections;
    using System.Collections.Generic;
	using System.Linq;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  SugarCpp.Compiler 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SugarCppParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "Block", "DEDENT", "EXPONENT", "Expr_Access", "Expr_Alloc", "Expr_Alloc_Auto", "Expr_Bin", "Expr_Block", "Expr_Call", "Expr_Cond", "Expr_Dict", "Expr_Lambda", "Expr_Match_Tuple", "Expr_New", "Expr_Prefix", "Expr_Return", "Expr_Suffix", "Expr_Tuple", "Func_Args", "Func_Def", "IDENT", "INDENT", "INT", "Left_Bracket", "NEWLINE", "Right_Bracket", "Root", "SP", "STRING", "Stmt_If", "Stmt_While", "Type_Tuple", "'!'", "'!='", "'%'", "'%='", "'&'", "'&='", "'('", "')'", "'*'", "'*='", "'+'", "'++'", "'+='", "','", "'-'", "'--'", "'-='", "'->'", "'.'", "'/'", "'/='", "':'", "'::'", "'<'", "'<<='", "'<='", "'='", "'=='", "'=>'", "'>'", "'>='", "'>>='", "'?'", "'['", "']'", "'^='", "'return'", "'|'", "'|='", "'~'"
	};
	public const int EOF=-1;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int Block=4;
	public const int DEDENT=5;
	public const int EXPONENT=6;
	public const int Expr_Access=7;
	public const int Expr_Alloc=8;
	public const int Expr_Alloc_Auto=9;
	public const int Expr_Bin=10;
	public const int Expr_Block=11;
	public const int Expr_Call=12;
	public const int Expr_Cond=13;
	public const int Expr_Dict=14;
	public const int Expr_Lambda=15;
	public const int Expr_Match_Tuple=16;
	public const int Expr_New=17;
	public const int Expr_Prefix=18;
	public const int Expr_Return=19;
	public const int Expr_Suffix=20;
	public const int Expr_Tuple=21;
	public const int Func_Args=22;
	public const int Func_Def=23;
	public const int IDENT=24;
	public const int INDENT=25;
	public const int INT=26;
	public const int Left_Bracket=27;
	public const int NEWLINE=28;
	public const int Right_Bracket=29;
	public const int Root=30;
	public const int SP=31;
	public const int STRING=32;
	public const int Stmt_If=33;
	public const int Stmt_While=34;
	public const int Type_Tuple=35;

	public SugarCppParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SugarCppParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return SugarCppParser.tokenNames; } }
	public override string GrammarFileName { get { return "SugarCpp.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_root();
	partial void LeaveRule_root();

	// $ANTLR start "root"
	// SugarCpp.g:122:8: public root : ( NEWLINE )* ( node )+ ( NEWLINE )* EOF ;
	[GrammarRule("root")]
	public AstParserRuleReturnScope<CommonTree, IToken> root()
	{
		EnterRule_root();
		EnterRule("root", 1);
		TraceIn("root", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NEWLINE1 = default(IToken);
		IToken NEWLINE3 = default(IToken);
		IToken EOF4 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> node2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NEWLINE1_tree = default(CommonTree);
		CommonTree NEWLINE3_tree = default(CommonTree);
		CommonTree EOF4_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "root");
		DebugLocation(122, 1);
		try
		{
			// SugarCpp.g:123:2: ( ( NEWLINE )* ( node )+ ( NEWLINE )* EOF )
			DebugEnterAlt(1);
			// SugarCpp.g:123:4: ( NEWLINE )* ( node )+ ( NEWLINE )* EOF
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(123, 4);
			// SugarCpp.g:123:4: ( NEWLINE )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==NEWLINE))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:123:4: NEWLINE
					{
					DebugLocation(123, 4);
					NEWLINE1=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_root283); 
					NEWLINE1_tree = (CommonTree)adaptor.Create(NEWLINE1);
					adaptor.AddChild(root_0, NEWLINE1_tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(123, 13);
			// SugarCpp.g:123:13: ( node )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==IDENT||LA2_0==42))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:123:14: node
					{
					DebugLocation(123, 14);
					PushFollow(Follow._node_in_root287);
					node2=node();
					PopFollow();

					adaptor.AddChild(root_0, node2.Tree);

					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(123, 21);
			// SugarCpp.g:123:21: ( NEWLINE )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==NEWLINE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:123:21: NEWLINE
					{
					DebugLocation(123, 21);
					NEWLINE3=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_root291); 
					NEWLINE3_tree = (CommonTree)adaptor.Create(NEWLINE3);
					adaptor.AddChild(root_0, NEWLINE3_tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(123, 30);
			EOF4=(IToken)Match(input,EOF,Follow._EOF_in_root294); 
			EOF4_tree = (CommonTree)adaptor.Create(EOF4);
			adaptor.AddChild(root_0, EOF4_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("root", 1);
			LeaveRule("root", 1);
			LeaveRule_root();
		}
		DebugLocation(124, 1);
		} finally { DebugExitRule(GrammarFileName, "root"); }
		return retval;

	}
	// $ANTLR end "root"

	partial void EnterRule_node();
	partial void LeaveRule_node();

	// $ANTLR start "node"
	// SugarCpp.g:126:1: node : func_def ;
	[GrammarRule("node")]
	private AstParserRuleReturnScope<CommonTree, IToken> node()
	{
		EnterRule_node();
		EnterRule("node", 2);
		TraceIn("node", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> func_def5 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "node");
		DebugLocation(126, 1);
		try
		{
			// SugarCpp.g:127:2: ( func_def )
			DebugEnterAlt(1);
			// SugarCpp.g:127:4: func_def
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(127, 4);
			PushFollow(Follow._func_def_in_node305);
			func_def5=func_def();
			PopFollow();

			adaptor.AddChild(root_0, func_def5.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("node", 2);
			LeaveRule("node", 2);
			LeaveRule_node();
		}
		DebugLocation(128, 1);
		} finally { DebugExitRule(GrammarFileName, "node"); }
		return retval;

	}
	// $ANTLR end "node"

	partial void EnterRule_type_name();
	partial void LeaveRule_type_name();

	// $ANTLR start "type_name"
	// SugarCpp.g:130:1: type_name : IDENT ;
	[GrammarRule("type_name")]
	private AstParserRuleReturnScope<CommonTree, IToken> type_name()
	{
		EnterRule_type_name();
		EnterRule("type_name", 3);
		TraceIn("type_name", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT6 = default(IToken);

		CommonTree IDENT6_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "type_name");
		DebugLocation(130, 1);
		try
		{
			// SugarCpp.g:131:2: ( IDENT )
			DebugEnterAlt(1);
			// SugarCpp.g:131:4: IDENT
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(131, 4);
			IDENT6=(IToken)Match(input,IDENT,Follow._IDENT_in_type_name316); 
			IDENT6_tree = (CommonTree)adaptor.Create(IDENT6);
			adaptor.AddChild(root_0, IDENT6_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_name", 3);
			LeaveRule("type_name", 3);
			LeaveRule_type_name();
		}
		DebugLocation(132, 1);
		} finally { DebugExitRule(GrammarFileName, "type_name"); }
		return retval;

	}
	// $ANTLR end "type_name"

	partial void EnterRule_func_type_name();
	partial void LeaveRule_func_type_name();

	// $ANTLR start "func_type_name"
	// SugarCpp.g:134:1: func_type_name : ( IDENT | '(' func_type_name ( ',' func_type_name ) ')' -> ^( Type_Tuple ( func_type_name )+ ) );
	[GrammarRule("func_type_name")]
	private AstParserRuleReturnScope<CommonTree, IToken> func_type_name()
	{
		EnterRule_func_type_name();
		EnterRule("func_type_name", 4);
		TraceIn("func_type_name", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT7 = default(IToken);
		IToken char_literal8 = default(IToken);
		IToken char_literal10 = default(IToken);
		IToken char_literal12 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_type_name9 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> func_type_name11 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT7_tree = default(CommonTree);
		CommonTree char_literal8_tree = default(CommonTree);
		CommonTree char_literal10_tree = default(CommonTree);
		CommonTree char_literal12_tree = default(CommonTree);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_func_type_name=new RewriteRuleSubtreeStream(adaptor,"rule func_type_name");
		try { DebugEnterRule(GrammarFileName, "func_type_name");
		DebugLocation(134, 1);
		try
		{
			// SugarCpp.g:135:2: ( IDENT | '(' func_type_name ( ',' func_type_name ) ')' -> ^( Type_Tuple ( func_type_name )+ ) )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==IDENT))
			{
				alt4 = 1;
			}
			else if ((LA4_0==42))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:135:4: IDENT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(135, 4);
				IDENT7=(IToken)Match(input,IDENT,Follow._IDENT_in_func_type_name328); 
				IDENT7_tree = (CommonTree)adaptor.Create(IDENT7);
				adaptor.AddChild(root_0, IDENT7_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SugarCpp.g:136:4: '(' func_type_name ( ',' func_type_name ) ')'
				{
				DebugLocation(136, 4);
				char_literal8=(IToken)Match(input,42,Follow._42_in_func_type_name334);  
				stream_42.Add(char_literal8);

				DebugLocation(136, 8);
				PushFollow(Follow._func_type_name_in_func_type_name336);
				func_type_name9=func_type_name();
				PopFollow();

				stream_func_type_name.Add(func_type_name9.Tree);
				DebugLocation(136, 23);
				// SugarCpp.g:136:23: ( ',' func_type_name )
				DebugEnterAlt(1);
				// SugarCpp.g:136:24: ',' func_type_name
				{
				DebugLocation(136, 24);
				char_literal10=(IToken)Match(input,49,Follow._49_in_func_type_name339);  
				stream_49.Add(char_literal10);

				DebugLocation(136, 28);
				PushFollow(Follow._func_type_name_in_func_type_name341);
				func_type_name11=func_type_name();
				PopFollow();

				stream_func_type_name.Add(func_type_name11.Tree);

				}

				DebugLocation(136, 44);
				char_literal12=(IToken)Match(input,43,Follow._43_in_func_type_name344);  
				stream_43.Add(char_literal12);



				{
				// AST REWRITE
				// elements: func_type_name
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 136:48: -> ^( Type_Tuple ( func_type_name )+ )
				{
					DebugLocation(136, 51);
					// SugarCpp.g:136:51: ^( Type_Tuple ( func_type_name )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(136, 53);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Type_Tuple, "Type_Tuple"), root_1);

					DebugLocation(136, 64);
					if (!(stream_func_type_name.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_func_type_name.HasNext )
					{
						DebugLocation(136, 64);
						adaptor.AddChild(root_1, stream_func_type_name.NextTree());

					}
					stream_func_type_name.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_type_name", 4);
			LeaveRule("func_type_name", 4);
			LeaveRule_func_type_name();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "func_type_name"); }
		return retval;

	}
	// $ANTLR end "func_type_name"

	partial void EnterRule_generic_parameter();
	partial void LeaveRule_generic_parameter();

	// $ANTLR start "generic_parameter"
	// SugarCpp.g:139:1: generic_parameter : IDENT ( ',' ! IDENT )* ;
	[GrammarRule("generic_parameter")]
	private AstParserRuleReturnScope<CommonTree, IToken> generic_parameter()
	{
		EnterRule_generic_parameter();
		EnterRule("generic_parameter", 5);
		TraceIn("generic_parameter", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT13 = default(IToken);
		IToken char_literal14 = default(IToken);
		IToken IDENT15 = default(IToken);

		CommonTree IDENT13_tree = default(CommonTree);
		CommonTree char_literal14_tree = default(CommonTree);
		CommonTree IDENT15_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "generic_parameter");
		DebugLocation(139, 1);
		try
		{
			// SugarCpp.g:140:2: ( IDENT ( ',' ! IDENT )* )
			DebugEnterAlt(1);
			// SugarCpp.g:140:4: IDENT ( ',' ! IDENT )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(140, 4);
			IDENT13=(IToken)Match(input,IDENT,Follow._IDENT_in_generic_parameter364); 
			IDENT13_tree = (CommonTree)adaptor.Create(IDENT13);
			adaptor.AddChild(root_0, IDENT13_tree);
			DebugLocation(140, 10);
			// SugarCpp.g:140:10: ( ',' ! IDENT )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==49))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:140:11: ',' ! IDENT
					{
					DebugLocation(140, 14);
					char_literal14=(IToken)Match(input,49,Follow._49_in_generic_parameter367); 
					DebugLocation(140, 16);
					IDENT15=(IToken)Match(input,IDENT,Follow._IDENT_in_generic_parameter370); 
					IDENT15_tree = (CommonTree)adaptor.Create(IDENT15);
					adaptor.AddChild(root_0, IDENT15_tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("generic_parameter", 5);
			LeaveRule("generic_parameter", 5);
			LeaveRule_generic_parameter();
		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "generic_parameter"); }
		return retval;

	}
	// $ANTLR end "generic_parameter"

	partial void EnterRule_func_args();
	partial void LeaveRule_func_args();

	// $ANTLR start "func_args"
	// SugarCpp.g:143:1: func_args : stmt_alloc ( ',' stmt_alloc )* -> ^( Func_Args ( stmt_alloc )* ) ;
	[GrammarRule("func_args")]
	private AstParserRuleReturnScope<CommonTree, IToken> func_args()
	{
		EnterRule_func_args();
		EnterRule("func_args", 6);
		TraceIn("func_args", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal17 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> stmt_alloc16 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> stmt_alloc18 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal17_tree = default(CommonTree);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_stmt_alloc=new RewriteRuleSubtreeStream(adaptor,"rule stmt_alloc");
		try { DebugEnterRule(GrammarFileName, "func_args");
		DebugLocation(143, 1);
		try
		{
			// SugarCpp.g:144:2: ( stmt_alloc ( ',' stmt_alloc )* -> ^( Func_Args ( stmt_alloc )* ) )
			DebugEnterAlt(1);
			// SugarCpp.g:144:4: stmt_alloc ( ',' stmt_alloc )*
			{
			DebugLocation(144, 4);
			PushFollow(Follow._stmt_alloc_in_func_args383);
			stmt_alloc16=stmt_alloc();
			PopFollow();

			stream_stmt_alloc.Add(stmt_alloc16.Tree);
			DebugLocation(144, 15);
			// SugarCpp.g:144:15: ( ',' stmt_alloc )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==49))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:144:16: ',' stmt_alloc
					{
					DebugLocation(144, 16);
					char_literal17=(IToken)Match(input,49,Follow._49_in_func_args386);  
					stream_49.Add(char_literal17);

					DebugLocation(144, 20);
					PushFollow(Follow._stmt_alloc_in_func_args388);
					stmt_alloc18=stmt_alloc();
					PopFollow();

					stream_stmt_alloc.Add(stmt_alloc18.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: stmt_alloc
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 144:33: -> ^( Func_Args ( stmt_alloc )* )
			{
				DebugLocation(144, 36);
				// SugarCpp.g:144:36: ^( Func_Args ( stmt_alloc )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(144, 38);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Func_Args, "Func_Args"), root_1);

				DebugLocation(144, 48);
				// SugarCpp.g:144:48: ( stmt_alloc )*
				while ( stream_stmt_alloc.HasNext )
				{
					DebugLocation(144, 48);
					adaptor.AddChild(root_1, stream_stmt_alloc.NextTree());

				}
				stream_stmt_alloc.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_args", 6);
			LeaveRule("func_args", 6);
			LeaveRule_func_args();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "func_args"); }
		return retval;

	}
	// $ANTLR end "func_args"

	partial void EnterRule_func_def();
	partial void LeaveRule_func_def();

	// $ANTLR start "func_def"
	// SugarCpp.g:147:1: func_def : func_type_name IDENT ( '<' generic_parameter '>' )? '(' ( func_args )? ')' stmt_block ;
	[GrammarRule("func_def")]
	private AstParserRuleReturnScope<CommonTree, IToken> func_def()
	{
		EnterRule_func_def();
		EnterRule("func_def", 7);
		TraceIn("func_def", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT20 = default(IToken);
		IToken char_literal21 = default(IToken);
		IToken char_literal23 = default(IToken);
		IToken char_literal24 = default(IToken);
		IToken char_literal26 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_type_name19 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> generic_parameter22 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> func_args25 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> stmt_block27 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT20_tree = default(CommonTree);
		CommonTree char_literal21_tree = default(CommonTree);
		CommonTree char_literal23_tree = default(CommonTree);
		CommonTree char_literal24_tree = default(CommonTree);
		CommonTree char_literal26_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "func_def");
		DebugLocation(147, 4);
		try
		{
			// SugarCpp.g:148:2: ( func_type_name IDENT ( '<' generic_parameter '>' )? '(' ( func_args )? ')' stmt_block )
			DebugEnterAlt(1);
			// SugarCpp.g:148:4: func_type_name IDENT ( '<' generic_parameter '>' )? '(' ( func_args )? ')' stmt_block
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(148, 4);
			PushFollow(Follow._func_type_name_in_func_def410);
			func_type_name19=func_type_name();
			PopFollow();

			adaptor.AddChild(root_0, func_type_name19.Tree);
			DebugLocation(148, 19);
			IDENT20=(IToken)Match(input,IDENT,Follow._IDENT_in_func_def412); 
			IDENT20_tree = (CommonTree)adaptor.Create(IDENT20);
			adaptor.AddChild(root_0, IDENT20_tree);
			DebugLocation(148, 25);
			// SugarCpp.g:148:25: ( '<' generic_parameter '>' )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==59))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:148:26: '<' generic_parameter '>'
				{
				DebugLocation(148, 26);
				char_literal21=(IToken)Match(input,59,Follow._59_in_func_def415); 
				char_literal21_tree = (CommonTree)adaptor.Create(char_literal21);
				adaptor.AddChild(root_0, char_literal21_tree);
				DebugLocation(148, 30);
				PushFollow(Follow._generic_parameter_in_func_def417);
				generic_parameter22=generic_parameter();
				PopFollow();

				adaptor.AddChild(root_0, generic_parameter22.Tree);
				DebugLocation(148, 48);
				char_literal23=(IToken)Match(input,65,Follow._65_in_func_def419); 
				char_literal23_tree = (CommonTree)adaptor.Create(char_literal23);
				adaptor.AddChild(root_0, char_literal23_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(148, 54);
			char_literal24=(IToken)Match(input,42,Follow._42_in_func_def423); 
			char_literal24_tree = (CommonTree)adaptor.Create(char_literal24);
			adaptor.AddChild(root_0, char_literal24_tree);
			DebugLocation(148, 58);
			// SugarCpp.g:148:58: ( func_args )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==IDENT||LA8_0==73))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:148:58: func_args
				{
				DebugLocation(148, 58);
				PushFollow(Follow._func_args_in_func_def425);
				func_args25=func_args();
				PopFollow();

				adaptor.AddChild(root_0, func_args25.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(148, 69);
			char_literal26=(IToken)Match(input,43,Follow._43_in_func_def428); 
			char_literal26_tree = (CommonTree)adaptor.Create(char_literal26);
			adaptor.AddChild(root_0, char_literal26_tree);
			DebugLocation(148, 73);
			PushFollow(Follow._stmt_block_in_func_def430);
			stmt_block27=stmt_block();
			PopFollow();

			adaptor.AddChild(root_0, stmt_block27.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_def", 7);
			LeaveRule("func_def", 7);
			LeaveRule_func_def();
		}
		DebugLocation(149, 4);
		} finally { DebugExitRule(GrammarFileName, "func_def"); }
		return retval;

	}
	// $ANTLR end "func_def"

	partial void EnterRule_stmt_block();
	partial void LeaveRule_stmt_block();

	// $ANTLR start "stmt_block"
	// SugarCpp.g:151:1: stmt_block : INDENT ( ( NEWLINE )+ stmt )* ( NEWLINE )* DEDENT ;
	[GrammarRule("stmt_block")]
	private AstParserRuleReturnScope<CommonTree, IToken> stmt_block()
	{
		EnterRule_stmt_block();
		EnterRule("stmt_block", 8);
		TraceIn("stmt_block", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INDENT28 = default(IToken);
		IToken NEWLINE29 = default(IToken);
		IToken NEWLINE31 = default(IToken);
		IToken DEDENT32 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> stmt30 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INDENT28_tree = default(CommonTree);
		CommonTree NEWLINE29_tree = default(CommonTree);
		CommonTree NEWLINE31_tree = default(CommonTree);
		CommonTree DEDENT32_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "stmt_block");
		DebugLocation(151, 1);
		try
		{
			// SugarCpp.g:152:2: ( INDENT ( ( NEWLINE )+ stmt )* ( NEWLINE )* DEDENT )
			DebugEnterAlt(1);
			// SugarCpp.g:152:4: INDENT ( ( NEWLINE )+ stmt )* ( NEWLINE )* DEDENT
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(152, 4);
			INDENT28=(IToken)Match(input,INDENT,Follow._INDENT_in_stmt_block444); 
			INDENT28_tree = (CommonTree)adaptor.Create(INDENT28);
			adaptor.AddChild(root_0, INDENT28_tree);
			DebugLocation(152, 11);
			// SugarCpp.g:152:11: ( ( NEWLINE )+ stmt )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				try
				{
					alt10 = dfa10.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:152:12: ( NEWLINE )+ stmt
					{
					DebugLocation(152, 12);
					// SugarCpp.g:152:12: ( NEWLINE )+
					int cnt9=0;
					try { DebugEnterSubRule(9);
					while (true)
					{
						int alt9=2;
						try { DebugEnterDecision(9, false);
						int LA9_0 = input.LA(1);

						if ((LA9_0==NEWLINE))
						{
							alt9 = 1;
						}


						} finally { DebugExitDecision(9); }
						switch (alt9)
						{
						case 1:
							DebugEnterAlt(1);
							// SugarCpp.g:152:12: NEWLINE
							{
							DebugLocation(152, 12);
							NEWLINE29=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_stmt_block447); 
							NEWLINE29_tree = (CommonTree)adaptor.Create(NEWLINE29);
							adaptor.AddChild(root_0, NEWLINE29_tree);

							}
							break;

						default:
							if (cnt9 >= 1)
								goto loop9;

							EarlyExitException eee9 = new EarlyExitException( 9, input );
							DebugRecognitionException(eee9);
							throw eee9;
						}
						cnt9++;
					}
					loop9:
						;

					} finally { DebugExitSubRule(9); }

					DebugLocation(152, 21);
					PushFollow(Follow._stmt_in_stmt_block450);
					stmt30=stmt();
					PopFollow();

					adaptor.AddChild(root_0, stmt30.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(152, 28);
			// SugarCpp.g:152:28: ( NEWLINE )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==NEWLINE))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:152:28: NEWLINE
					{
					DebugLocation(152, 28);
					NEWLINE31=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_stmt_block454); 
					NEWLINE31_tree = (CommonTree)adaptor.Create(NEWLINE31);
					adaptor.AddChild(root_0, NEWLINE31_tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(152, 37);
			DEDENT32=(IToken)Match(input,DEDENT,Follow._DEDENT_in_stmt_block457); 
			DEDENT32_tree = (CommonTree)adaptor.Create(DEDENT32);
			adaptor.AddChild(root_0, DEDENT32_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt_block", 8);
			LeaveRule("stmt_block", 8);
			LeaveRule_stmt_block();
		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt_block"); }
		return retval;

	}
	// $ANTLR end "stmt_block"

	partial void EnterRule_stmt();
	partial void LeaveRule_stmt();

	// $ANTLR start "stmt"
	// SugarCpp.g:155:1: stmt : stmt_expr ;
	[GrammarRule("stmt")]
	private AstParserRuleReturnScope<CommonTree, IToken> stmt()
	{
		EnterRule_stmt();
		EnterRule("stmt", 9);
		TraceIn("stmt", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> stmt_expr33 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "stmt");
		DebugLocation(155, 1);
		try
		{
			// SugarCpp.g:156:2: ( stmt_expr )
			DebugEnterAlt(1);
			// SugarCpp.g:156:4: stmt_expr
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(156, 4);
			PushFollow(Follow._stmt_expr_in_stmt468);
			stmt_expr33=stmt_expr();
			PopFollow();

			adaptor.AddChild(root_0, stmt_expr33.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt", 9);
			LeaveRule("stmt", 9);
			LeaveRule_stmt();
		}
		DebugLocation(157, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt"); }
		return retval;

	}
	// $ANTLR end "stmt"

	partial void EnterRule_stmt_expr();
	partial void LeaveRule_stmt_expr();

	// $ANTLR start "stmt_expr"
	// SugarCpp.g:159:1: stmt_expr : ( stmt_alloc | stmt_return );
	[GrammarRule("stmt_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> stmt_expr()
	{
		EnterRule_stmt_expr();
		EnterRule("stmt_expr", 10);
		TraceIn("stmt_expr", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> stmt_alloc34 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> stmt_return35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "stmt_expr");
		DebugLocation(159, 1);
		try
		{
			// SugarCpp.g:160:2: ( stmt_alloc | stmt_return )
			int alt12=2;
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==IDENT||LA12_0==73))
			{
				alt12 = 1;
			}
			else if ((LA12_0==72))
			{
				alt12 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:160:4: stmt_alloc
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(160, 4);
				PushFollow(Follow._stmt_alloc_in_stmt_expr479);
				stmt_alloc34=stmt_alloc();
				PopFollow();

				adaptor.AddChild(root_0, stmt_alloc34.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SugarCpp.g:161:4: stmt_return
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(161, 4);
				PushFollow(Follow._stmt_return_in_stmt_expr484);
				stmt_return35=stmt_return();
				PopFollow();

				adaptor.AddChild(root_0, stmt_return35.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt_expr", 10);
			LeaveRule("stmt_expr", 10);
			LeaveRule_stmt_expr();
		}
		DebugLocation(162, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt_expr"); }
		return retval;

	}
	// $ANTLR end "stmt_expr"

	partial void EnterRule_stmt_return();
	partial void LeaveRule_stmt_return();

	// $ANTLR start "stmt_return"
	// SugarCpp.g:164:1: stmt_return : 'return' ( expr )? -> ^( Expr_Return ( expr )? ) ;
	[GrammarRule("stmt_return")]
	private AstParserRuleReturnScope<CommonTree, IToken> stmt_return()
	{
		EnterRule_stmt_return();
		EnterRule("stmt_return", 11);
		TraceIn("stmt_return", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal36 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expr37 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal36_tree = default(CommonTree);
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "stmt_return");
		DebugLocation(164, 1);
		try
		{
			// SugarCpp.g:165:2: ( 'return' ( expr )? -> ^( Expr_Return ( expr )? ) )
			DebugEnterAlt(1);
			// SugarCpp.g:165:4: 'return' ( expr )?
			{
			DebugLocation(165, 4);
			string_literal36=(IToken)Match(input,72,Follow._72_in_stmt_return495);  
			stream_72.Add(string_literal36);

			DebugLocation(165, 13);
			// SugarCpp.g:165:13: ( expr )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==IDENT||LA13_0==INT||LA13_0==STRING||LA13_0==36||LA13_0==40||LA13_0==42||LA13_0==44||(LA13_0>=46 && LA13_0<=47)||(LA13_0>=50 && LA13_0<=51)||LA13_0==75))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:165:13: expr
				{
				DebugLocation(165, 13);
				PushFollow(Follow._expr_in_stmt_return497);
				expr37=expr();
				PopFollow();

				stream_expr.Add(expr37.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 165:19: -> ^( Expr_Return ( expr )? )
			{
				DebugLocation(165, 22);
				// SugarCpp.g:165:22: ^( Expr_Return ( expr )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(165, 24);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Return, "Expr_Return"), root_1);

				DebugLocation(165, 36);
				// SugarCpp.g:165:36: ( expr )?
				if (stream_expr.HasNext)
				{
					DebugLocation(165, 36);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt_return", 11);
			LeaveRule("stmt_return", 11);
			LeaveRule_stmt_return();
		}
		DebugLocation(166, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt_return"); }
		return retval;

	}
	// $ANTLR end "stmt_return"

	partial void EnterRule_stmt_alloc();
	partial void LeaveRule_stmt_alloc();

	// $ANTLR start "stmt_alloc"
	// SugarCpp.g:168:1: stmt_alloc : ( type_name IDENT ( '=' expr )? -> ^( Expr_Alloc type_name IDENT ( expr )? ) | '|' IDENT '|' ( '=' expr )? -> ^( Expr_Alloc_Auto IDENT ( expr )? ) );
	[GrammarRule("stmt_alloc")]
	private AstParserRuleReturnScope<CommonTree, IToken> stmt_alloc()
	{
		EnterRule_stmt_alloc();
		EnterRule("stmt_alloc", 12);
		TraceIn("stmt_alloc", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT39 = default(IToken);
		IToken char_literal40 = default(IToken);
		IToken char_literal42 = default(IToken);
		IToken IDENT43 = default(IToken);
		IToken char_literal44 = default(IToken);
		IToken char_literal45 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> type_name38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expr41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expr46 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT39_tree = default(CommonTree);
		CommonTree char_literal40_tree = default(CommonTree);
		CommonTree char_literal42_tree = default(CommonTree);
		CommonTree IDENT43_tree = default(CommonTree);
		CommonTree char_literal44_tree = default(CommonTree);
		CommonTree char_literal45_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleSubtreeStream stream_type_name=new RewriteRuleSubtreeStream(adaptor,"rule type_name");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "stmt_alloc");
		DebugLocation(168, 1);
		try
		{
			// SugarCpp.g:169:2: ( type_name IDENT ( '=' expr )? -> ^( Expr_Alloc type_name IDENT ( expr )? ) | '|' IDENT '|' ( '=' expr )? -> ^( Expr_Alloc_Auto IDENT ( expr )? ) )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==IDENT))
			{
				alt16 = 1;
			}
			else if ((LA16_0==73))
			{
				alt16 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:169:4: type_name IDENT ( '=' expr )?
				{
				DebugLocation(169, 4);
				PushFollow(Follow._type_name_in_stmt_alloc518);
				type_name38=type_name();
				PopFollow();

				stream_type_name.Add(type_name38.Tree);
				DebugLocation(169, 14);
				IDENT39=(IToken)Match(input,IDENT,Follow._IDENT_in_stmt_alloc520);  
				stream_IDENT.Add(IDENT39);

				DebugLocation(169, 20);
				// SugarCpp.g:169:20: ( '=' expr )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==62))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:169:21: '=' expr
					{
					DebugLocation(169, 21);
					char_literal40=(IToken)Match(input,62,Follow._62_in_stmt_alloc523);  
					stream_62.Add(char_literal40);

					DebugLocation(169, 25);
					PushFollow(Follow._expr_in_stmt_alloc525);
					expr41=expr();
					PopFollow();

					stream_expr.Add(expr41.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(14); }



				{
				// AST REWRITE
				// elements: type_name, expr, IDENT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 169:32: -> ^( Expr_Alloc type_name IDENT ( expr )? )
				{
					DebugLocation(169, 35);
					// SugarCpp.g:169:35: ^( Expr_Alloc type_name IDENT ( expr )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(169, 37);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Alloc, "Expr_Alloc"), root_1);

					DebugLocation(169, 48);
					adaptor.AddChild(root_1, stream_type_name.NextTree());
					DebugLocation(169, 58);
					adaptor.AddChild(root_1, stream_IDENT.NextNode());
					DebugLocation(169, 64);
					// SugarCpp.g:169:64: ( expr )?
					if (stream_expr.HasNext)
					{
						DebugLocation(169, 64);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SugarCpp.g:170:4: '|' IDENT '|' ( '=' expr )?
				{
				DebugLocation(170, 4);
				char_literal42=(IToken)Match(input,73,Follow._73_in_stmt_alloc545);  
				stream_73.Add(char_literal42);

				DebugLocation(170, 8);
				IDENT43=(IToken)Match(input,IDENT,Follow._IDENT_in_stmt_alloc547);  
				stream_IDENT.Add(IDENT43);

				DebugLocation(170, 14);
				char_literal44=(IToken)Match(input,73,Follow._73_in_stmt_alloc549);  
				stream_73.Add(char_literal44);

				DebugLocation(170, 18);
				// SugarCpp.g:170:18: ( '=' expr )?
				int alt15=2;
				try { DebugEnterSubRule(15);
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==62))
				{
					alt15 = 1;
				}
				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:170:19: '=' expr
					{
					DebugLocation(170, 19);
					char_literal45=(IToken)Match(input,62,Follow._62_in_stmt_alloc552);  
					stream_62.Add(char_literal45);

					DebugLocation(170, 23);
					PushFollow(Follow._expr_in_stmt_alloc554);
					expr46=expr();
					PopFollow();

					stream_expr.Add(expr46.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(15); }



				{
				// AST REWRITE
				// elements: IDENT, expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 170:30: -> ^( Expr_Alloc_Auto IDENT ( expr )? )
				{
					DebugLocation(170, 33);
					// SugarCpp.g:170:33: ^( Expr_Alloc_Auto IDENT ( expr )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(170, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Alloc_Auto, "Expr_Alloc_Auto"), root_1);

					DebugLocation(170, 51);
					adaptor.AddChild(root_1, stream_IDENT.NextNode());
					DebugLocation(170, 57);
					// SugarCpp.g:170:57: ( expr )?
					if (stream_expr.HasNext)
					{
						DebugLocation(170, 57);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt_alloc", 12);
			LeaveRule("stmt_alloc", 12);
			LeaveRule_stmt_alloc();
		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt_alloc"); }
		return retval;

	}
	// $ANTLR end "stmt_alloc"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// SugarCpp.g:173:1: expr : lambda_expr ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 13);
		TraceIn("expr", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> lambda_expr47 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(173, 1);
		try
		{
			// SugarCpp.g:174:2: ( lambda_expr )
			DebugEnterAlt(1);
			// SugarCpp.g:174:4: lambda_expr
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(174, 4);
			PushFollow(Follow._lambda_expr_in_expr578);
			lambda_expr47=lambda_expr();
			PopFollow();

			adaptor.AddChild(root_0, lambda_expr47.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 13);
			LeaveRule("expr", 13);
			LeaveRule_expr();
		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_lambda_expr();
	partial void LeaveRule_lambda_expr();

	// $ANTLR start "lambda_expr"
	// SugarCpp.g:177:1: lambda_expr : ( '(' func_args ')' '=>' modify_expr -> ^( Expr_Lambda func_args modify_expr ) | modify_expr );
	[GrammarRule("lambda_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> lambda_expr()
	{
		EnterRule_lambda_expr();
		EnterRule("lambda_expr", 14);
		TraceIn("lambda_expr", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal48 = default(IToken);
		IToken char_literal50 = default(IToken);
		IToken string_literal51 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_args49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> modify_expr52 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> modify_expr53 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal48_tree = default(CommonTree);
		CommonTree char_literal50_tree = default(CommonTree);
		CommonTree string_literal51_tree = default(CommonTree);
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleSubtreeStream stream_modify_expr=new RewriteRuleSubtreeStream(adaptor,"rule modify_expr");
		RewriteRuleSubtreeStream stream_func_args=new RewriteRuleSubtreeStream(adaptor,"rule func_args");
		try { DebugEnterRule(GrammarFileName, "lambda_expr");
		DebugLocation(177, 1);
		try
		{
			// SugarCpp.g:178:2: ( '(' func_args ')' '=>' modify_expr -> ^( Expr_Lambda func_args modify_expr ) | modify_expr )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==42))
			{
				switch (input.LA(2))
				{
				case IDENT:
					{
					int LA17_3 = input.LA(3);

					if ((LA17_3==IDENT))
					{
						alt17 = 1;
					}
					else if (((LA17_3>=37 && LA17_3<=39)||(LA17_3>=41 && LA17_3<=56)||(LA17_3>=58 && LA17_3<=63)||(LA17_3>=65 && LA17_3<=69)||LA17_3==71||LA17_3==74))
					{
						alt17 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 73:
					{
					alt17 = 1;
					}
					break;
				case INT:
				case STRING:
				case 36:
				case 40:
				case 42:
				case 44:
				case 46:
				case 47:
				case 50:
				case 51:
				case 75:
					{
					alt17 = 2;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else if ((LA17_0==IDENT||LA17_0==INT||LA17_0==STRING||LA17_0==36||LA17_0==40||LA17_0==44||(LA17_0>=46 && LA17_0<=47)||(LA17_0>=50 && LA17_0<=51)||LA17_0==75))
			{
				alt17 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:178:4: '(' func_args ')' '=>' modify_expr
				{
				DebugLocation(178, 4);
				char_literal48=(IToken)Match(input,42,Follow._42_in_lambda_expr589);  
				stream_42.Add(char_literal48);

				DebugLocation(178, 8);
				PushFollow(Follow._func_args_in_lambda_expr591);
				func_args49=func_args();
				PopFollow();

				stream_func_args.Add(func_args49.Tree);
				DebugLocation(178, 18);
				char_literal50=(IToken)Match(input,43,Follow._43_in_lambda_expr593);  
				stream_43.Add(char_literal50);

				DebugLocation(178, 22);
				string_literal51=(IToken)Match(input,64,Follow._64_in_lambda_expr595);  
				stream_64.Add(string_literal51);

				DebugLocation(178, 27);
				PushFollow(Follow._modify_expr_in_lambda_expr597);
				modify_expr52=modify_expr();
				PopFollow();

				stream_modify_expr.Add(modify_expr52.Tree);


				{
				// AST REWRITE
				// elements: func_args, modify_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 178:39: -> ^( Expr_Lambda func_args modify_expr )
				{
					DebugLocation(178, 42);
					// SugarCpp.g:178:42: ^( Expr_Lambda func_args modify_expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(178, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Lambda, "Expr_Lambda"), root_1);

					DebugLocation(178, 56);
					adaptor.AddChild(root_1, stream_func_args.NextTree());
					DebugLocation(178, 66);
					adaptor.AddChild(root_1, stream_modify_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SugarCpp.g:179:4: modify_expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(179, 4);
				PushFollow(Follow._modify_expr_in_lambda_expr612);
				modify_expr53=modify_expr();
				PopFollow();

				adaptor.AddChild(root_0, modify_expr53.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lambda_expr", 14);
			LeaveRule("lambda_expr", 14);
			LeaveRule_lambda_expr();
		}
		DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "lambda_expr"); }
		return retval;

	}
	// $ANTLR end "lambda_expr"

	partial void EnterRule_modify_expr_op();
	partial void LeaveRule_modify_expr_op();

	// $ANTLR start "modify_expr_op"
	// SugarCpp.g:182:1: modify_expr_op : ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '^=' | '|=' | '<<=' | '>>=' );
	[GrammarRule("modify_expr_op")]
	private AstParserRuleReturnScope<CommonTree, IToken> modify_expr_op()
	{
		EnterRule_modify_expr_op();
		EnterRule("modify_expr_op", 15);
		TraceIn("modify_expr_op", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set54 = default(IToken);

		CommonTree set54_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "modify_expr_op");
		DebugLocation(182, 92);
		try
		{
			// SugarCpp.g:182:15: ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '^=' | '|=' | '<<=' | '>>=' )
			DebugEnterAlt(1);
			// SugarCpp.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(182, 15);

			set54=(IToken)input.LT(1);
			if (input.LA(1)==39||input.LA(1)==41||input.LA(1)==45||input.LA(1)==48||input.LA(1)==52||input.LA(1)==56||input.LA(1)==60||input.LA(1)==62||input.LA(1)==67||input.LA(1)==71||input.LA(1)==74)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set54));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("modify_expr_op", 15);
			LeaveRule("modify_expr_op", 15);
			LeaveRule_modify_expr_op();
		}
		DebugLocation(182, 92);
		} finally { DebugExitRule(GrammarFileName, "modify_expr_op"); }
		return retval;

	}
	// $ANTLR end "modify_expr_op"

	partial void EnterRule_modify_expr();
	partial void LeaveRule_modify_expr();

	// $ANTLR start "modify_expr"
	// SugarCpp.g:183:1: modify_expr : (a= cond_expr -> $a) ( modify_expr_op b= cond_expr -> ^( Expr_Bin modify_expr_op $modify_expr $b) )* ;
	[GrammarRule("modify_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> modify_expr()
	{
		EnterRule_modify_expr();
		EnterRule("modify_expr", 16);
		TraceIn("modify_expr", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> modify_expr_op55 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_cond_expr=new RewriteRuleSubtreeStream(adaptor,"rule cond_expr");
		RewriteRuleSubtreeStream stream_modify_expr_op=new RewriteRuleSubtreeStream(adaptor,"rule modify_expr_op");
		try { DebugEnterRule(GrammarFileName, "modify_expr");
		DebugLocation(183, 1);
		try
		{
			// SugarCpp.g:184:2: ( (a= cond_expr -> $a) ( modify_expr_op b= cond_expr -> ^( Expr_Bin modify_expr_op $modify_expr $b) )* )
			DebugEnterAlt(1);
			// SugarCpp.g:184:4: (a= cond_expr -> $a) ( modify_expr_op b= cond_expr -> ^( Expr_Bin modify_expr_op $modify_expr $b) )*
			{
			DebugLocation(184, 4);
			// SugarCpp.g:184:4: (a= cond_expr -> $a)
			DebugEnterAlt(1);
			// SugarCpp.g:184:5: a= cond_expr
			{
			DebugLocation(184, 6);
			PushFollow(Follow._cond_expr_in_modify_expr673);
			a=cond_expr();
			PopFollow();

			stream_cond_expr.Add(a.Tree);


			{
			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval, a
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 184:17: -> $a
			{
				DebugLocation(184, 21);
				adaptor.AddChild(root_0, stream_a.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(184, 24);
			// SugarCpp.g:184:24: ( modify_expr_op b= cond_expr -> ^( Expr_Bin modify_expr_op $modify_expr $b) )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==39||LA18_0==41||LA18_0==45||LA18_0==48||LA18_0==52||LA18_0==56||LA18_0==60||LA18_0==62||LA18_0==67||LA18_0==71||LA18_0==74))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:184:25: modify_expr_op b= cond_expr
					{
					DebugLocation(184, 25);
					PushFollow(Follow._modify_expr_op_in_modify_expr682);
					modify_expr_op55=modify_expr_op();
					PopFollow();

					stream_modify_expr_op.Add(modify_expr_op55.Tree);
					DebugLocation(184, 41);
					PushFollow(Follow._cond_expr_in_modify_expr686);
					b=cond_expr();
					PopFollow();

					stream_cond_expr.Add(b.Tree);


					{
					// AST REWRITE
					// elements: b, modify_expr, modify_expr_op
					// token labels: 
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 184:52: -> ^( Expr_Bin modify_expr_op $modify_expr $b)
					{
						DebugLocation(184, 55);
						// SugarCpp.g:184:55: ^( Expr_Bin modify_expr_op $modify_expr $b)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(184, 57);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Bin, "Expr_Bin"), root_1);

						DebugLocation(184, 66);
						adaptor.AddChild(root_1, stream_modify_expr_op.NextTree());
						DebugLocation(184, 82);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(184, 95);
						adaptor.AddChild(root_1, stream_b.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("modify_expr", 16);
			LeaveRule("modify_expr", 16);
			LeaveRule_modify_expr();
		}
		DebugLocation(185, 1);
		} finally { DebugExitRule(GrammarFileName, "modify_expr"); }
		return retval;

	}
	// $ANTLR end "modify_expr"

	partial void EnterRule_cond_expr_item();
	partial void LeaveRule_cond_expr_item();

	// $ANTLR start "cond_expr_item"
	// SugarCpp.g:187:1: cond_expr_item : cond_expr ;
	[GrammarRule("cond_expr_item")]
	private AstParserRuleReturnScope<CommonTree, IToken> cond_expr_item()
	{
		EnterRule_cond_expr_item();
		EnterRule("cond_expr_item", 17);
		TraceIn("cond_expr_item", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> cond_expr56 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "cond_expr_item");
		DebugLocation(187, 26);
		try
		{
			// SugarCpp.g:187:15: ( cond_expr )
			DebugEnterAlt(1);
			// SugarCpp.g:187:17: cond_expr
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(187, 17);
			PushFollow(Follow._cond_expr_in_cond_expr_item711);
			cond_expr56=cond_expr();
			PopFollow();

			adaptor.AddChild(root_0, cond_expr56.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cond_expr_item", 17);
			LeaveRule("cond_expr_item", 17);
			LeaveRule_cond_expr_item();
		}
		DebugLocation(187, 26);
		} finally { DebugExitRule(GrammarFileName, "cond_expr_item"); }
		return retval;

	}
	// $ANTLR end "cond_expr_item"

	partial void EnterRule_cond_expr();
	partial void LeaveRule_cond_expr();

	// $ANTLR start "cond_expr"
	// SugarCpp.g:188:1: cond_expr : (a= cmp_expr -> $a) ( '?' a= cond_expr_item ':' b= cond_expr_item -> ^( Expr_Cond $cond_expr $a $b) )? ;
	[GrammarRule("cond_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> cond_expr()
	{
		EnterRule_cond_expr();
		EnterRule("cond_expr", 18);
		TraceIn("cond_expr", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal57 = default(IToken);
		IToken char_literal58 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal57_tree = default(CommonTree);
		CommonTree char_literal58_tree = default(CommonTree);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleSubtreeStream stream_cond_expr_item=new RewriteRuleSubtreeStream(adaptor,"rule cond_expr_item");
		RewriteRuleSubtreeStream stream_cmp_expr=new RewriteRuleSubtreeStream(adaptor,"rule cmp_expr");
		try { DebugEnterRule(GrammarFileName, "cond_expr");
		DebugLocation(188, 1);
		try
		{
			// SugarCpp.g:189:2: ( (a= cmp_expr -> $a) ( '?' a= cond_expr_item ':' b= cond_expr_item -> ^( Expr_Cond $cond_expr $a $b) )? )
			DebugEnterAlt(1);
			// SugarCpp.g:189:4: (a= cmp_expr -> $a) ( '?' a= cond_expr_item ':' b= cond_expr_item -> ^( Expr_Cond $cond_expr $a $b) )?
			{
			DebugLocation(189, 4);
			// SugarCpp.g:189:4: (a= cmp_expr -> $a)
			DebugEnterAlt(1);
			// SugarCpp.g:189:5: a= cmp_expr
			{
			DebugLocation(189, 6);
			PushFollow(Follow._cmp_expr_in_cond_expr723);
			a=cmp_expr();
			PopFollow();

			stream_cmp_expr.Add(a.Tree);


			{
			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval, a
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 189:16: -> $a
			{
				DebugLocation(189, 20);
				adaptor.AddChild(root_0, stream_a.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(189, 23);
			// SugarCpp.g:189:23: ( '?' a= cond_expr_item ':' b= cond_expr_item -> ^( Expr_Cond $cond_expr $a $b) )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==68))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:189:24: '?' a= cond_expr_item ':' b= cond_expr_item
				{
				DebugLocation(189, 24);
				char_literal57=(IToken)Match(input,68,Follow._68_in_cond_expr732);  
				stream_68.Add(char_literal57);

				DebugLocation(189, 29);
				PushFollow(Follow._cond_expr_item_in_cond_expr736);
				a=cond_expr_item();
				PopFollow();

				stream_cond_expr_item.Add(a.Tree);
				DebugLocation(189, 45);
				char_literal58=(IToken)Match(input,57,Follow._57_in_cond_expr738);  
				stream_57.Add(char_literal58);

				DebugLocation(189, 50);
				PushFollow(Follow._cond_expr_item_in_cond_expr742);
				b=cond_expr_item();
				PopFollow();

				stream_cond_expr_item.Add(b.Tree);


				{
				// AST REWRITE
				// elements: cond_expr, b, a
				// token labels: 
				// rule labels: retval, b, a
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 189:66: -> ^( Expr_Cond $cond_expr $a $b)
				{
					DebugLocation(189, 69);
					// SugarCpp.g:189:69: ^( Expr_Cond $cond_expr $a $b)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(189, 71);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Cond, "Expr_Cond"), root_1);

					DebugLocation(189, 82);
					adaptor.AddChild(root_1, stream_retval.NextTree());
					DebugLocation(189, 93);
					adaptor.AddChild(root_1, stream_a.NextTree());
					DebugLocation(189, 96);
					adaptor.AddChild(root_1, stream_b.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cond_expr", 18);
			LeaveRule("cond_expr", 18);
			LeaveRule_cond_expr();
		}
		DebugLocation(190, 1);
		} finally { DebugExitRule(GrammarFileName, "cond_expr"); }
		return retval;

	}
	// $ANTLR end "cond_expr"

	partial void EnterRule_cmp_expr_op();
	partial void LeaveRule_cmp_expr_op();

	// $ANTLR start "cmp_expr_op"
	// SugarCpp.g:192:1: cmp_expr_op : ( '<' | '<=' | '>' | '>=' | '==' | '!=' );
	[GrammarRule("cmp_expr_op")]
	private AstParserRuleReturnScope<CommonTree, IToken> cmp_expr_op()
	{
		EnterRule_cmp_expr_op();
		EnterRule("cmp_expr_op", 19);
		TraceIn("cmp_expr_op", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set59 = default(IToken);

		CommonTree set59_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "cmp_expr_op");
		DebugLocation(192, 51);
		try
		{
			// SugarCpp.g:192:12: ( '<' | '<=' | '>' | '>=' | '==' | '!=' )
			DebugEnterAlt(1);
			// SugarCpp.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(192, 12);

			set59=(IToken)input.LT(1);
			if (input.LA(1)==37||input.LA(1)==59||input.LA(1)==61||input.LA(1)==63||(input.LA(1)>=65 && input.LA(1)<=66))
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set59));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cmp_expr_op", 19);
			LeaveRule("cmp_expr_op", 19);
			LeaveRule_cmp_expr_op();
		}
		DebugLocation(192, 51);
		} finally { DebugExitRule(GrammarFileName, "cmp_expr_op"); }
		return retval;

	}
	// $ANTLR end "cmp_expr_op"

	partial void EnterRule_cmp_expr();
	partial void LeaveRule_cmp_expr();

	// $ANTLR start "cmp_expr"
	// SugarCpp.g:193:1: cmp_expr : (a= add_expr -> $a) ( cmp_expr_op b= add_expr -> ^( Expr_Bin cmp_expr_op $cmp_expr $b) )* ;
	[GrammarRule("cmp_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> cmp_expr()
	{
		EnterRule_cmp_expr();
		EnterRule("cmp_expr", 20);
		TraceIn("cmp_expr", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> cmp_expr_op60 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_cmp_expr_op=new RewriteRuleSubtreeStream(adaptor,"rule cmp_expr_op");
		RewriteRuleSubtreeStream stream_add_expr=new RewriteRuleSubtreeStream(adaptor,"rule add_expr");
		try { DebugEnterRule(GrammarFileName, "cmp_expr");
		DebugLocation(193, 1);
		try
		{
			// SugarCpp.g:194:2: ( (a= add_expr -> $a) ( cmp_expr_op b= add_expr -> ^( Expr_Bin cmp_expr_op $cmp_expr $b) )* )
			DebugEnterAlt(1);
			// SugarCpp.g:194:4: (a= add_expr -> $a) ( cmp_expr_op b= add_expr -> ^( Expr_Bin cmp_expr_op $cmp_expr $b) )*
			{
			DebugLocation(194, 4);
			// SugarCpp.g:194:4: (a= add_expr -> $a)
			DebugEnterAlt(1);
			// SugarCpp.g:194:5: a= add_expr
			{
			DebugLocation(194, 6);
			PushFollow(Follow._add_expr_in_cmp_expr801);
			a=add_expr();
			PopFollow();

			stream_add_expr.Add(a.Tree);


			{
			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval, a
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 194:16: -> $a
			{
				DebugLocation(194, 20);
				adaptor.AddChild(root_0, stream_a.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(194, 23);
			// SugarCpp.g:194:23: ( cmp_expr_op b= add_expr -> ^( Expr_Bin cmp_expr_op $cmp_expr $b) )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==37||LA20_0==59||LA20_0==61||LA20_0==63||(LA20_0>=65 && LA20_0<=66)))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:194:24: cmp_expr_op b= add_expr
					{
					DebugLocation(194, 24);
					PushFollow(Follow._cmp_expr_op_in_cmp_expr810);
					cmp_expr_op60=cmp_expr_op();
					PopFollow();

					stream_cmp_expr_op.Add(cmp_expr_op60.Tree);
					DebugLocation(194, 37);
					PushFollow(Follow._add_expr_in_cmp_expr814);
					b=add_expr();
					PopFollow();

					stream_add_expr.Add(b.Tree);


					{
					// AST REWRITE
					// elements: cmp_expr, cmp_expr_op, b
					// token labels: 
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 194:47: -> ^( Expr_Bin cmp_expr_op $cmp_expr $b)
					{
						DebugLocation(194, 50);
						// SugarCpp.g:194:50: ^( Expr_Bin cmp_expr_op $cmp_expr $b)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(194, 52);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Bin, "Expr_Bin"), root_1);

						DebugLocation(194, 61);
						adaptor.AddChild(root_1, stream_cmp_expr_op.NextTree());
						DebugLocation(194, 74);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(194, 84);
						adaptor.AddChild(root_1, stream_b.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cmp_expr", 20);
			LeaveRule("cmp_expr", 20);
			LeaveRule_cmp_expr();
		}
		DebugLocation(195, 1);
		} finally { DebugExitRule(GrammarFileName, "cmp_expr"); }
		return retval;

	}
	// $ANTLR end "cmp_expr"

	partial void EnterRule_add_expr();
	partial void LeaveRule_add_expr();

	// $ANTLR start "add_expr"
	// SugarCpp.g:197:1: add_expr : (a= mul_expr -> $a) ( '+' b= mul_expr -> ^( Expr_Bin '+' $add_expr $b) | '-' b= mul_expr -> ^( Expr_Bin '-' $add_expr $b) )* ;
	[GrammarRule("add_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> add_expr()
	{
		EnterRule_add_expr();
		EnterRule("add_expr", 21);
		TraceIn("add_expr", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal61 = default(IToken);
		IToken char_literal62 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal61_tree = default(CommonTree);
		CommonTree char_literal62_tree = default(CommonTree);
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		RewriteRuleSubtreeStream stream_mul_expr=new RewriteRuleSubtreeStream(adaptor,"rule mul_expr");
		try { DebugEnterRule(GrammarFileName, "add_expr");
		DebugLocation(197, 1);
		try
		{
			// SugarCpp.g:198:2: ( (a= mul_expr -> $a) ( '+' b= mul_expr -> ^( Expr_Bin '+' $add_expr $b) | '-' b= mul_expr -> ^( Expr_Bin '-' $add_expr $b) )* )
			DebugEnterAlt(1);
			// SugarCpp.g:198:4: (a= mul_expr -> $a) ( '+' b= mul_expr -> ^( Expr_Bin '+' $add_expr $b) | '-' b= mul_expr -> ^( Expr_Bin '-' $add_expr $b) )*
			{
			DebugLocation(198, 4);
			// SugarCpp.g:198:4: (a= mul_expr -> $a)
			DebugEnterAlt(1);
			// SugarCpp.g:198:5: a= mul_expr
			{
			DebugLocation(198, 6);
			PushFollow(Follow._mul_expr_in_add_expr844);
			a=mul_expr();
			PopFollow();

			stream_mul_expr.Add(a.Tree);


			{
			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval, a
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 198:16: -> $a
			{
				DebugLocation(198, 20);
				adaptor.AddChild(root_0, stream_a.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(198, 23);
			// SugarCpp.g:198:23: ( '+' b= mul_expr -> ^( Expr_Bin '+' $add_expr $b) | '-' b= mul_expr -> ^( Expr_Bin '-' $add_expr $b) )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=3;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==46))
				{
					alt21 = 1;
				}
				else if ((LA21_0==50))
				{
					alt21 = 2;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:198:25: '+' b= mul_expr
					{
					DebugLocation(198, 25);
					char_literal61=(IToken)Match(input,46,Follow._46_in_add_expr854);  
					stream_46.Add(char_literal61);

					DebugLocation(198, 30);
					PushFollow(Follow._mul_expr_in_add_expr858);
					b=mul_expr();
					PopFollow();

					stream_mul_expr.Add(b.Tree);


					{
					// AST REWRITE
					// elements: 46, b, add_expr
					// token labels: 
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 198:40: -> ^( Expr_Bin '+' $add_expr $b)
					{
						DebugLocation(198, 43);
						// SugarCpp.g:198:43: ^( Expr_Bin '+' $add_expr $b)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(198, 45);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Bin, "Expr_Bin"), root_1);

						DebugLocation(198, 54);
						adaptor.AddChild(root_1, stream_46.NextNode());
						DebugLocation(198, 59);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(198, 69);
						adaptor.AddChild(root_1, stream_b.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// SugarCpp.g:199:10: '-' b= mul_expr
					{
					DebugLocation(199, 10);
					char_literal62=(IToken)Match(input,50,Follow._50_in_add_expr883);  
					stream_50.Add(char_literal62);

					DebugLocation(199, 15);
					PushFollow(Follow._mul_expr_in_add_expr887);
					b=mul_expr();
					PopFollow();

					stream_mul_expr.Add(b.Tree);


					{
					// AST REWRITE
					// elements: b, add_expr, 50
					// token labels: 
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 199:25: -> ^( Expr_Bin '-' $add_expr $b)
					{
						DebugLocation(199, 28);
						// SugarCpp.g:199:28: ^( Expr_Bin '-' $add_expr $b)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(199, 30);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Bin, "Expr_Bin"), root_1);

						DebugLocation(199, 39);
						adaptor.AddChild(root_1, stream_50.NextNode());
						DebugLocation(199, 44);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(199, 54);
						adaptor.AddChild(root_1, stream_b.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("add_expr", 21);
			LeaveRule("add_expr", 21);
			LeaveRule_add_expr();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "add_expr"); }
		return retval;

	}
	// $ANTLR end "add_expr"

	partial void EnterRule_mul_expr();
	partial void LeaveRule_mul_expr();

	// $ANTLR start "mul_expr"
	// SugarCpp.g:203:1: mul_expr : (a= prefix_expr -> $a) ( '*' b= prefix_expr -> ^( Expr_Bin '*' $mul_expr $b) | '/' b= prefix_expr -> ^( Expr_Bin '/' $mul_expr $b) | '%' b= prefix_expr -> ^( Expr_Bin '%' $mul_expr $b) )* ;
	[GrammarRule("mul_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> mul_expr()
	{
		EnterRule_mul_expr();
		EnterRule("mul_expr", 22);
		TraceIn("mul_expr", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken char_literal65 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> b = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal63_tree = default(CommonTree);
		CommonTree char_literal64_tree = default(CommonTree);
		CommonTree char_literal65_tree = default(CommonTree);
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleSubtreeStream stream_prefix_expr=new RewriteRuleSubtreeStream(adaptor,"rule prefix_expr");
		try { DebugEnterRule(GrammarFileName, "mul_expr");
		DebugLocation(203, 1);
		try
		{
			// SugarCpp.g:204:2: ( (a= prefix_expr -> $a) ( '*' b= prefix_expr -> ^( Expr_Bin '*' $mul_expr $b) | '/' b= prefix_expr -> ^( Expr_Bin '/' $mul_expr $b) | '%' b= prefix_expr -> ^( Expr_Bin '%' $mul_expr $b) )* )
			DebugEnterAlt(1);
			// SugarCpp.g:204:4: (a= prefix_expr -> $a) ( '*' b= prefix_expr -> ^( Expr_Bin '*' $mul_expr $b) | '/' b= prefix_expr -> ^( Expr_Bin '/' $mul_expr $b) | '%' b= prefix_expr -> ^( Expr_Bin '%' $mul_expr $b) )*
			{
			DebugLocation(204, 4);
			// SugarCpp.g:204:4: (a= prefix_expr -> $a)
			DebugEnterAlt(1);
			// SugarCpp.g:204:5: a= prefix_expr
			{
			DebugLocation(204, 6);
			PushFollow(Follow._prefix_expr_in_mul_expr925);
			a=prefix_expr();
			PopFollow();

			stream_prefix_expr.Add(a.Tree);


			{
			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval, a
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 204:19: -> $a
			{
				DebugLocation(204, 23);
				adaptor.AddChild(root_0, stream_a.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(204, 26);
			// SugarCpp.g:204:26: ( '*' b= prefix_expr -> ^( Expr_Bin '*' $mul_expr $b) | '/' b= prefix_expr -> ^( Expr_Bin '/' $mul_expr $b) | '%' b= prefix_expr -> ^( Expr_Bin '%' $mul_expr $b) )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=4;
				try { DebugEnterDecision(22, false);
				switch (input.LA(1))
				{
				case 44:
					{
					alt22 = 1;
					}
					break;
				case 55:
					{
					alt22 = 2;
					}
					break;
				case 38:
					{
					alt22 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:204:28: '*' b= prefix_expr
					{
					DebugLocation(204, 28);
					char_literal63=(IToken)Match(input,44,Follow._44_in_mul_expr935);  
					stream_44.Add(char_literal63);

					DebugLocation(204, 33);
					PushFollow(Follow._prefix_expr_in_mul_expr939);
					b=prefix_expr();
					PopFollow();

					stream_prefix_expr.Add(b.Tree);


					{
					// AST REWRITE
					// elements: b, mul_expr, 44
					// token labels: 
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 204:46: -> ^( Expr_Bin '*' $mul_expr $b)
					{
						DebugLocation(204, 49);
						// SugarCpp.g:204:49: ^( Expr_Bin '*' $mul_expr $b)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(204, 51);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Bin, "Expr_Bin"), root_1);

						DebugLocation(204, 60);
						adaptor.AddChild(root_1, stream_44.NextNode());
						DebugLocation(204, 65);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(204, 75);
						adaptor.AddChild(root_1, stream_b.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// SugarCpp.g:205:13: '/' b= prefix_expr
					{
					DebugLocation(205, 13);
					char_literal64=(IToken)Match(input,55,Follow._55_in_mul_expr967);  
					stream_55.Add(char_literal64);

					DebugLocation(205, 18);
					PushFollow(Follow._prefix_expr_in_mul_expr971);
					b=prefix_expr();
					PopFollow();

					stream_prefix_expr.Add(b.Tree);


					{
					// AST REWRITE
					// elements: b, mul_expr, 55
					// token labels: 
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 205:31: -> ^( Expr_Bin '/' $mul_expr $b)
					{
						DebugLocation(205, 34);
						// SugarCpp.g:205:34: ^( Expr_Bin '/' $mul_expr $b)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(205, 36);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Bin, "Expr_Bin"), root_1);

						DebugLocation(205, 45);
						adaptor.AddChild(root_1, stream_55.NextNode());
						DebugLocation(205, 50);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(205, 60);
						adaptor.AddChild(root_1, stream_b.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// SugarCpp.g:206:13: '%' b= prefix_expr
					{
					DebugLocation(206, 13);
					char_literal65=(IToken)Match(input,38,Follow._38_in_mul_expr999);  
					stream_38.Add(char_literal65);

					DebugLocation(206, 18);
					PushFollow(Follow._prefix_expr_in_mul_expr1003);
					b=prefix_expr();
					PopFollow();

					stream_prefix_expr.Add(b.Tree);


					{
					// AST REWRITE
					// elements: mul_expr, 38, b
					// token labels: 
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 206:31: -> ^( Expr_Bin '%' $mul_expr $b)
					{
						DebugLocation(206, 34);
						// SugarCpp.g:206:34: ^( Expr_Bin '%' $mul_expr $b)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(206, 36);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Bin, "Expr_Bin"), root_1);

						DebugLocation(206, 45);
						adaptor.AddChild(root_1, stream_38.NextNode());
						DebugLocation(206, 50);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(206, 60);
						adaptor.AddChild(root_1, stream_b.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mul_expr", 22);
			LeaveRule("mul_expr", 22);
			LeaveRule_mul_expr();
		}
		DebugLocation(208, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_expr"); }
		return retval;

	}
	// $ANTLR end "mul_expr"

	partial void EnterRule_prefix_expr_op();
	partial void LeaveRule_prefix_expr_op();

	// $ANTLR start "prefix_expr_op"
	// SugarCpp.g:210:1: prefix_expr_op : ( '!' | '~' | '++' | '--' | '-' | '+' | '*' | '&' );
	[GrammarRule("prefix_expr_op")]
	private AstParserRuleReturnScope<CommonTree, IToken> prefix_expr_op()
	{
		EnterRule_prefix_expr_op();
		EnterRule("prefix_expr_op", 23);
		TraceIn("prefix_expr_op", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set66 = default(IToken);

		CommonTree set66_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "prefix_expr_op");
		DebugLocation(210, 64);
		try
		{
			// SugarCpp.g:210:15: ( '!' | '~' | '++' | '--' | '-' | '+' | '*' | '&' )
			DebugEnterAlt(1);
			// SugarCpp.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(210, 15);

			set66=(IToken)input.LT(1);
			if (input.LA(1)==36||input.LA(1)==40||input.LA(1)==44||(input.LA(1)>=46 && input.LA(1)<=47)||(input.LA(1)>=50 && input.LA(1)<=51)||input.LA(1)==75)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set66));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prefix_expr_op", 23);
			LeaveRule("prefix_expr_op", 23);
			LeaveRule_prefix_expr_op();
		}
		DebugLocation(210, 64);
		} finally { DebugExitRule(GrammarFileName, "prefix_expr_op"); }
		return retval;

	}
	// $ANTLR end "prefix_expr_op"

	partial void EnterRule_prefix_expr();
	partial void LeaveRule_prefix_expr();

	// $ANTLR start "prefix_expr"
	// SugarCpp.g:211:1: prefix_expr : ( ( prefix_expr_op prefix_expr ) -> ^( Expr_Prefix prefix_expr_op prefix_expr ) | suffix_expr );
	[GrammarRule("prefix_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> prefix_expr()
	{
		EnterRule_prefix_expr();
		EnterRule("prefix_expr", 24);
		TraceIn("prefix_expr", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> prefix_expr_op67 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> prefix_expr68 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> suffix_expr69 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_prefix_expr=new RewriteRuleSubtreeStream(adaptor,"rule prefix_expr");
		RewriteRuleSubtreeStream stream_prefix_expr_op=new RewriteRuleSubtreeStream(adaptor,"rule prefix_expr_op");
		try { DebugEnterRule(GrammarFileName, "prefix_expr");
		DebugLocation(211, 1);
		try
		{
			// SugarCpp.g:212:2: ( ( prefix_expr_op prefix_expr ) -> ^( Expr_Prefix prefix_expr_op prefix_expr ) | suffix_expr )
			int alt23=2;
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==36||LA23_0==40||LA23_0==44||(LA23_0>=46 && LA23_0<=47)||(LA23_0>=50 && LA23_0<=51)||LA23_0==75))
			{
				alt23 = 1;
			}
			else if ((LA23_0==IDENT||LA23_0==INT||LA23_0==STRING||LA23_0==42))
			{
				alt23 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:212:4: ( prefix_expr_op prefix_expr )
				{
				DebugLocation(212, 4);
				// SugarCpp.g:212:4: ( prefix_expr_op prefix_expr )
				DebugEnterAlt(1);
				// SugarCpp.g:212:5: prefix_expr_op prefix_expr
				{
				DebugLocation(212, 5);
				PushFollow(Follow._prefix_expr_op_in_prefix_expr1077);
				prefix_expr_op67=prefix_expr_op();
				PopFollow();

				stream_prefix_expr_op.Add(prefix_expr_op67.Tree);
				DebugLocation(212, 20);
				PushFollow(Follow._prefix_expr_in_prefix_expr1079);
				prefix_expr68=prefix_expr();
				PopFollow();

				stream_prefix_expr.Add(prefix_expr68.Tree);

				}



				{
				// AST REWRITE
				// elements: prefix_expr_op, prefix_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 212:33: -> ^( Expr_Prefix prefix_expr_op prefix_expr )
				{
					DebugLocation(212, 36);
					// SugarCpp.g:212:36: ^( Expr_Prefix prefix_expr_op prefix_expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(212, 38);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Prefix, "Expr_Prefix"), root_1);

					DebugLocation(212, 50);
					adaptor.AddChild(root_1, stream_prefix_expr_op.NextTree());
					DebugLocation(212, 65);
					adaptor.AddChild(root_1, stream_prefix_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SugarCpp.g:213:4: suffix_expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(213, 4);
				PushFollow(Follow._suffix_expr_in_prefix_expr1095);
				suffix_expr69=suffix_expr();
				PopFollow();

				adaptor.AddChild(root_0, suffix_expr69.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prefix_expr", 24);
			LeaveRule("prefix_expr", 24);
			LeaveRule_prefix_expr();
		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "prefix_expr"); }
		return retval;

	}
	// $ANTLR end "prefix_expr"

	partial void EnterRule_expr_list();
	partial void LeaveRule_expr_list();

	// $ANTLR start "expr_list"
	// SugarCpp.g:216:1: expr_list : expr ( ',' ! expr )* ;
	[GrammarRule("expr_list")]
	private AstParserRuleReturnScope<CommonTree, IToken> expr_list()
	{
		EnterRule_expr_list();
		EnterRule("expr_list", 25);
		TraceIn("expr_list", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal71 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expr70 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expr72 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal71_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr_list");
		DebugLocation(216, 1);
		try
		{
			// SugarCpp.g:217:2: ( expr ( ',' ! expr )* )
			DebugEnterAlt(1);
			// SugarCpp.g:217:4: expr ( ',' ! expr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(217, 4);
			PushFollow(Follow._expr_in_expr_list1107);
			expr70=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr70.Tree);
			DebugLocation(217, 9);
			// SugarCpp.g:217:9: ( ',' ! expr )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==49))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:217:10: ',' ! expr
					{
					DebugLocation(217, 13);
					char_literal71=(IToken)Match(input,49,Follow._49_in_expr_list1110); 
					DebugLocation(217, 15);
					PushFollow(Follow._expr_in_expr_list1113);
					expr72=expr();
					PopFollow();

					adaptor.AddChild(root_0, expr72.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_list", 25);
			LeaveRule("expr_list", 25);
			LeaveRule_expr_list();
		}
		DebugLocation(218, 1);
		} finally { DebugExitRule(GrammarFileName, "expr_list"); }
		return retval;

	}
	// $ANTLR end "expr_list"

	partial void EnterRule_suffix_expr();
	partial void LeaveRule_suffix_expr();

	// $ANTLR start "suffix_expr"
	// SugarCpp.g:220:1: suffix_expr : (a= atom_expr -> $a) ( '++' -> ^( Expr_Suffix '++' $suffix_expr) | '--' -> ^( Expr_Suffix '--' $suffix_expr) | '.' IDENT -> ^( Expr_Access '.' $suffix_expr IDENT ) | '->' IDENT -> ^( Expr_Access '->' $suffix_expr IDENT ) | '::' IDENT -> ^( Expr_Access '::' $suffix_expr IDENT ) | '(' ( expr_list )? ')' -> ^( Expr_Call $suffix_expr ( expr_list )? ) | '[' expr ']' -> ^( Expr_Dict $suffix_expr expr ) )* ;
	[GrammarRule("suffix_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> suffix_expr()
	{
		EnterRule_suffix_expr();
		EnterRule("suffix_expr", 26);
		TraceIn("suffix_expr", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal73 = default(IToken);
		IToken string_literal74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken IDENT76 = default(IToken);
		IToken string_literal77 = default(IToken);
		IToken IDENT78 = default(IToken);
		IToken string_literal79 = default(IToken);
		IToken IDENT80 = default(IToken);
		IToken char_literal81 = default(IToken);
		IToken char_literal83 = default(IToken);
		IToken char_literal84 = default(IToken);
		IToken char_literal86 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expr_list82 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expr85 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal73_tree = default(CommonTree);
		CommonTree string_literal74_tree = default(CommonTree);
		CommonTree char_literal75_tree = default(CommonTree);
		CommonTree IDENT76_tree = default(CommonTree);
		CommonTree string_literal77_tree = default(CommonTree);
		CommonTree IDENT78_tree = default(CommonTree);
		CommonTree string_literal79_tree = default(CommonTree);
		CommonTree IDENT80_tree = default(CommonTree);
		CommonTree char_literal81_tree = default(CommonTree);
		CommonTree char_literal83_tree = default(CommonTree);
		CommonTree char_literal84_tree = default(CommonTree);
		CommonTree char_literal86_tree = default(CommonTree);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_51=new RewriteRuleITokenStream(adaptor,"token 51");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleSubtreeStream stream_atom_expr=new RewriteRuleSubtreeStream(adaptor,"rule atom_expr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_expr_list=new RewriteRuleSubtreeStream(adaptor,"rule expr_list");
		try { DebugEnterRule(GrammarFileName, "suffix_expr");
		DebugLocation(220, 1);
		try
		{
			// SugarCpp.g:221:2: ( (a= atom_expr -> $a) ( '++' -> ^( Expr_Suffix '++' $suffix_expr) | '--' -> ^( Expr_Suffix '--' $suffix_expr) | '.' IDENT -> ^( Expr_Access '.' $suffix_expr IDENT ) | '->' IDENT -> ^( Expr_Access '->' $suffix_expr IDENT ) | '::' IDENT -> ^( Expr_Access '::' $suffix_expr IDENT ) | '(' ( expr_list )? ')' -> ^( Expr_Call $suffix_expr ( expr_list )? ) | '[' expr ']' -> ^( Expr_Dict $suffix_expr expr ) )* )
			DebugEnterAlt(1);
			// SugarCpp.g:221:4: (a= atom_expr -> $a) ( '++' -> ^( Expr_Suffix '++' $suffix_expr) | '--' -> ^( Expr_Suffix '--' $suffix_expr) | '.' IDENT -> ^( Expr_Access '.' $suffix_expr IDENT ) | '->' IDENT -> ^( Expr_Access '->' $suffix_expr IDENT ) | '::' IDENT -> ^( Expr_Access '::' $suffix_expr IDENT ) | '(' ( expr_list )? ')' -> ^( Expr_Call $suffix_expr ( expr_list )? ) | '[' expr ']' -> ^( Expr_Dict $suffix_expr expr ) )*
			{
			DebugLocation(221, 4);
			// SugarCpp.g:221:4: (a= atom_expr -> $a)
			DebugEnterAlt(1);
			// SugarCpp.g:221:5: a= atom_expr
			{
			DebugLocation(221, 6);
			PushFollow(Follow._atom_expr_in_suffix_expr1129);
			a=atom_expr();
			PopFollow();

			stream_atom_expr.Add(a.Tree);


			{
			// AST REWRITE
			// elements: a
			// token labels: 
			// rule labels: retval, a
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 221:17: -> $a
			{
				DebugLocation(221, 21);
				adaptor.AddChild(root_0, stream_a.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(221, 24);
			// SugarCpp.g:221:24: ( '++' -> ^( Expr_Suffix '++' $suffix_expr) | '--' -> ^( Expr_Suffix '--' $suffix_expr) | '.' IDENT -> ^( Expr_Access '.' $suffix_expr IDENT ) | '->' IDENT -> ^( Expr_Access '->' $suffix_expr IDENT ) | '::' IDENT -> ^( Expr_Access '::' $suffix_expr IDENT ) | '(' ( expr_list )? ')' -> ^( Expr_Call $suffix_expr ( expr_list )? ) | '[' expr ']' -> ^( Expr_Dict $suffix_expr expr ) )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=8;
				try { DebugEnterDecision(26, false);
				switch (input.LA(1))
				{
				case 47:
					{
					alt26 = 1;
					}
					break;
				case 51:
					{
					alt26 = 2;
					}
					break;
				case 54:
					{
					alt26 = 3;
					}
					break;
				case 53:
					{
					alt26 = 4;
					}
					break;
				case 58:
					{
					alt26 = 5;
					}
					break;
				case 42:
					{
					alt26 = 6;
					}
					break;
				case 69:
					{
					alt26 = 7;
					}
					break;
				}

				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:221:26: '++'
					{
					DebugLocation(221, 26);
					string_literal73=(IToken)Match(input,47,Follow._47_in_suffix_expr1139);  
					stream_47.Add(string_literal73);



					{
					// AST REWRITE
					// elements: suffix_expr, 47
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 221:31: -> ^( Expr_Suffix '++' $suffix_expr)
					{
						DebugLocation(221, 34);
						// SugarCpp.g:221:34: ^( Expr_Suffix '++' $suffix_expr)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(221, 36);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Suffix, "Expr_Suffix"), root_1);

						DebugLocation(221, 48);
						adaptor.AddChild(root_1, stream_47.NextNode());
						DebugLocation(221, 54);
						adaptor.AddChild(root_1, stream_retval.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// SugarCpp.g:222:14: '--'
					{
					DebugLocation(222, 14);
					string_literal74=(IToken)Match(input,51,Follow._51_in_suffix_expr1165);  
					stream_51.Add(string_literal74);



					{
					// AST REWRITE
					// elements: suffix_expr, 51
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 222:19: -> ^( Expr_Suffix '--' $suffix_expr)
					{
						DebugLocation(222, 22);
						// SugarCpp.g:222:22: ^( Expr_Suffix '--' $suffix_expr)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(222, 24);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Suffix, "Expr_Suffix"), root_1);

						DebugLocation(222, 36);
						adaptor.AddChild(root_1, stream_51.NextNode());
						DebugLocation(222, 42);
						adaptor.AddChild(root_1, stream_retval.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// SugarCpp.g:223:11: '.' IDENT
					{
					DebugLocation(223, 11);
					char_literal75=(IToken)Match(input,54,Follow._54_in_suffix_expr1188);  
					stream_54.Add(char_literal75);

					DebugLocation(223, 15);
					IDENT76=(IToken)Match(input,IDENT,Follow._IDENT_in_suffix_expr1190);  
					stream_IDENT.Add(IDENT76);



					{
					// AST REWRITE
					// elements: 54, suffix_expr, IDENT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 223:21: -> ^( Expr_Access '.' $suffix_expr IDENT )
					{
						DebugLocation(223, 24);
						// SugarCpp.g:223:24: ^( Expr_Access '.' $suffix_expr IDENT )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(223, 26);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Access, "Expr_Access"), root_1);

						DebugLocation(223, 38);
						adaptor.AddChild(root_1, stream_54.NextNode());
						DebugLocation(223, 43);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(223, 55);
						adaptor.AddChild(root_1, stream_IDENT.NextNode());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// SugarCpp.g:224:11: '->' IDENT
					{
					DebugLocation(224, 11);
					string_literal77=(IToken)Match(input,53,Follow._53_in_suffix_expr1215);  
					stream_53.Add(string_literal77);

					DebugLocation(224, 16);
					IDENT78=(IToken)Match(input,IDENT,Follow._IDENT_in_suffix_expr1217);  
					stream_IDENT.Add(IDENT78);



					{
					// AST REWRITE
					// elements: suffix_expr, 53, IDENT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 224:22: -> ^( Expr_Access '->' $suffix_expr IDENT )
					{
						DebugLocation(224, 25);
						// SugarCpp.g:224:25: ^( Expr_Access '->' $suffix_expr IDENT )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(224, 27);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Access, "Expr_Access"), root_1);

						DebugLocation(224, 39);
						adaptor.AddChild(root_1, stream_53.NextNode());
						DebugLocation(224, 45);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(224, 57);
						adaptor.AddChild(root_1, stream_IDENT.NextNode());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// SugarCpp.g:225:11: '::' IDENT
					{
					DebugLocation(225, 11);
					string_literal79=(IToken)Match(input,58,Follow._58_in_suffix_expr1242);  
					stream_58.Add(string_literal79);

					DebugLocation(225, 16);
					IDENT80=(IToken)Match(input,IDENT,Follow._IDENT_in_suffix_expr1244);  
					stream_IDENT.Add(IDENT80);



					{
					// AST REWRITE
					// elements: IDENT, suffix_expr, 58
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 225:22: -> ^( Expr_Access '::' $suffix_expr IDENT )
					{
						DebugLocation(225, 25);
						// SugarCpp.g:225:25: ^( Expr_Access '::' $suffix_expr IDENT )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(225, 27);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Access, "Expr_Access"), root_1);

						DebugLocation(225, 39);
						adaptor.AddChild(root_1, stream_58.NextNode());
						DebugLocation(225, 45);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(225, 57);
						adaptor.AddChild(root_1, stream_IDENT.NextNode());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// SugarCpp.g:226:11: '(' ( expr_list )? ')'
					{
					DebugLocation(226, 11);
					char_literal81=(IToken)Match(input,42,Follow._42_in_suffix_expr1269);  
					stream_42.Add(char_literal81);

					DebugLocation(226, 15);
					// SugarCpp.g:226:15: ( expr_list )?
					int alt25=2;
					try { DebugEnterSubRule(25);
					try { DebugEnterDecision(25, false);
					int LA25_0 = input.LA(1);

					if ((LA25_0==IDENT||LA25_0==INT||LA25_0==STRING||LA25_0==36||LA25_0==40||LA25_0==42||LA25_0==44||(LA25_0>=46 && LA25_0<=47)||(LA25_0>=50 && LA25_0<=51)||LA25_0==75))
					{
						alt25 = 1;
					}
					} finally { DebugExitDecision(25); }
					switch (alt25)
					{
					case 1:
						DebugEnterAlt(1);
						// SugarCpp.g:226:15: expr_list
						{
						DebugLocation(226, 15);
						PushFollow(Follow._expr_list_in_suffix_expr1271);
						expr_list82=expr_list();
						PopFollow();

						stream_expr_list.Add(expr_list82.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(25); }

					DebugLocation(226, 26);
					char_literal83=(IToken)Match(input,43,Follow._43_in_suffix_expr1274);  
					stream_43.Add(char_literal83);



					{
					// AST REWRITE
					// elements: suffix_expr, expr_list
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 226:30: -> ^( Expr_Call $suffix_expr ( expr_list )? )
					{
						DebugLocation(226, 33);
						// SugarCpp.g:226:33: ^( Expr_Call $suffix_expr ( expr_list )? )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(226, 35);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Call, "Expr_Call"), root_1);

						DebugLocation(226, 46);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(226, 58);
						// SugarCpp.g:226:58: ( expr_list )?
						if (stream_expr_list.HasNext)
						{
							DebugLocation(226, 58);
							adaptor.AddChild(root_1, stream_expr_list.NextTree());

						}
						stream_expr_list.Reset();

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 7:
					DebugEnterAlt(7);
					// SugarCpp.g:227:11: '[' expr ']'
					{
					DebugLocation(227, 11);
					char_literal84=(IToken)Match(input,69,Follow._69_in_suffix_expr1298);  
					stream_69.Add(char_literal84);

					DebugLocation(227, 15);
					PushFollow(Follow._expr_in_suffix_expr1300);
					expr85=expr();
					PopFollow();

					stream_expr.Add(expr85.Tree);
					DebugLocation(227, 20);
					char_literal86=(IToken)Match(input,70,Follow._70_in_suffix_expr1302);  
					stream_70.Add(char_literal86);



					{
					// AST REWRITE
					// elements: expr, suffix_expr
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 227:24: -> ^( Expr_Dict $suffix_expr expr )
					{
						DebugLocation(227, 27);
						// SugarCpp.g:227:27: ^( Expr_Dict $suffix_expr expr )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(227, 29);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Dict, "Expr_Dict"), root_1);

						DebugLocation(227, 40);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(227, 52);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("suffix_expr", 26);
			LeaveRule("suffix_expr", 26);
			LeaveRule_suffix_expr();
		}
		DebugLocation(229, 1);
		} finally { DebugExitRule(GrammarFileName, "suffix_expr"); }
		return retval;

	}
	// $ANTLR end "suffix_expr"

	partial void EnterRule_atom_expr();
	partial void LeaveRule_atom_expr();

	// $ANTLR start "atom_expr"
	// SugarCpp.g:231:1: atom_expr : ( INT | IDENT | STRING | '(' expr ( ',' expr )* ')' -> { more_than_one }? ^( Expr_Tuple ( expr )+ ) -> expr );
	[GrammarRule("atom_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> atom_expr()
	{
		EnterRule_atom_expr();
		EnterRule("atom_expr", 27);
		TraceIn("atom_expr", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT87 = default(IToken);
		IToken IDENT88 = default(IToken);
		IToken STRING89 = default(IToken);
		IToken char_literal90 = default(IToken);
		IToken char_literal92 = default(IToken);
		IToken char_literal94 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expr91 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expr93 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT87_tree = default(CommonTree);
		CommonTree IDENT88_tree = default(CommonTree);
		CommonTree STRING89_tree = default(CommonTree);
		CommonTree char_literal90_tree = default(CommonTree);
		CommonTree char_literal92_tree = default(CommonTree);
		CommonTree char_literal94_tree = default(CommonTree);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "atom_expr");
		DebugLocation(231, 1);
		try
		{
			// SugarCpp.g:232:2: ( INT | IDENT | STRING | '(' expr ( ',' expr )* ')' -> { more_than_one }? ^( Expr_Tuple ( expr )+ ) -> expr )
			int alt28=4;
			try { DebugEnterDecision(28, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt28 = 1;
				}
				break;
			case IDENT:
				{
				alt28 = 2;
				}
				break;
			case STRING:
				{
				alt28 = 3;
				}
				break;
			case 42:
				{
				alt28 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:232:4: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(232, 4);
				INT87=(IToken)Match(input,INT,Follow._INT_in_atom_expr1338); 
				INT87_tree = (CommonTree)adaptor.Create(INT87);
				adaptor.AddChild(root_0, INT87_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SugarCpp.g:233:4: IDENT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(233, 4);
				IDENT88=(IToken)Match(input,IDENT,Follow._IDENT_in_atom_expr1343); 
				IDENT88_tree = (CommonTree)adaptor.Create(IDENT88);
				adaptor.AddChild(root_0, IDENT88_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SugarCpp.g:234:4: STRING
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(234, 4);
				STRING89=(IToken)Match(input,STRING,Follow._STRING_in_atom_expr1348); 
				STRING89_tree = (CommonTree)adaptor.Create(STRING89);
				adaptor.AddChild(root_0, STRING89_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SugarCpp.g:235:4: '(' expr ( ',' expr )* ')'
				{
				DebugLocation(235, 4);
				 bool more_than_one = false; 
				DebugLocation(236, 3);
				char_literal90=(IToken)Match(input,42,Follow._42_in_atom_expr1357);  
				stream_42.Add(char_literal90);

				DebugLocation(236, 7);
				PushFollow(Follow._expr_in_atom_expr1359);
				expr91=expr();
				PopFollow();

				stream_expr.Add(expr91.Tree);
				DebugLocation(236, 12);
				// SugarCpp.g:236:12: ( ',' expr )*
				try { DebugEnterSubRule(27);
				while (true)
				{
					int alt27=2;
					try { DebugEnterDecision(27, false);
					int LA27_0 = input.LA(1);

					if ((LA27_0==49))
					{
						alt27 = 1;
					}


					} finally { DebugExitDecision(27); }
					switch ( alt27 )
					{
					case 1:
						DebugEnterAlt(1);
						// SugarCpp.g:236:13: ',' expr
						{
						DebugLocation(236, 13);
						char_literal92=(IToken)Match(input,49,Follow._49_in_atom_expr1362);  
						stream_49.Add(char_literal92);

						DebugLocation(236, 17);
						PushFollow(Follow._expr_in_atom_expr1364);
						expr93=expr();
						PopFollow();

						stream_expr.Add(expr93.Tree);
						DebugLocation(236, 22);
						 more_than_one = true; 

						}
						break;

					default:
						goto loop27;
					}
				}

				loop27:
					;

				} finally { DebugExitSubRule(27); }

				DebugLocation(236, 51);
				char_literal94=(IToken)Match(input,43,Follow._43_in_atom_expr1371);  
				stream_43.Add(char_literal94);



				{
				// AST REWRITE
				// elements: expr, expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 237:3: -> { more_than_one }? ^( Expr_Tuple ( expr )+ )
				if ( more_than_one )
				{
					DebugLocation(237, 25);
					// SugarCpp.g:237:25: ^( Expr_Tuple ( expr )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(237, 27);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr_Tuple, "Expr_Tuple"), root_1);

					DebugLocation(237, 38);
					if (!(stream_expr.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(237, 38);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 238:3: -> expr
				{
					DebugLocation(238, 6);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom_expr", 27);
			LeaveRule("atom_expr", 27);
			LeaveRule_atom_expr();
		}
		DebugLocation(239, 1);
		} finally { DebugExitRule(GrammarFileName, "atom_expr"); }
		return retval;

	}
	// $ANTLR end "atom_expr"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// SugarCpp.g:241:1: lvalue : IDENT ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<CommonTree, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 28);
		TraceIn("lvalue", 28);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT95 = default(IToken);

		CommonTree IDENT95_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(241, 1);
		try
		{
			// SugarCpp.g:242:2: ( IDENT )
			DebugEnterAlt(1);
			// SugarCpp.g:242:4: IDENT
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(242, 4);
			IDENT95=(IToken)Match(input,IDENT,Follow._IDENT_in_lvalue1401); 
			IDENT95_tree = (CommonTree)adaptor.Create(IDENT95);
			adaptor.AddChild(root_0, IDENT95_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue", 28);
			LeaveRule("lvalue", 28);
			LeaveRule_lvalue();
		}
		DebugLocation(244, 1);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"
	#endregion Rules


	#region DFA
	private DFA10 dfa10;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa10 = new DFA10( this );
	}

	private class DFA10 : DFA
	{
		private const string DFA10_eotS =
			"\x4\xFFFF";
		private const string DFA10_eofS =
			"\x4\xFFFF";
		private const string DFA10_minS =
			"\x2\x5\x2\xFFFF";
		private const string DFA10_maxS =
			"\x1\x1C\x1\x49\x2\xFFFF";
		private const string DFA10_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA10_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA10_transitionS =
			{
				"\x1\x2\x16\xFFFF\x1\x1",
				"\x1\x2\x12\xFFFF\x1\x3\x3\xFFFF\x1\x1\x2B\xFFFF\x2\x3",
				"",
				""
			};

		private static readonly short[] DFA10_eot = DFA.UnpackEncodedString(DFA10_eotS);
		private static readonly short[] DFA10_eof = DFA.UnpackEncodedString(DFA10_eofS);
		private static readonly char[] DFA10_min = DFA.UnpackEncodedStringToUnsignedChars(DFA10_minS);
		private static readonly char[] DFA10_max = DFA.UnpackEncodedStringToUnsignedChars(DFA10_maxS);
		private static readonly short[] DFA10_accept = DFA.UnpackEncodedString(DFA10_acceptS);
		private static readonly short[] DFA10_special = DFA.UnpackEncodedString(DFA10_specialS);
		private static readonly short[][] DFA10_transition;

		static DFA10()
		{
			int numStates = DFA10_transitionS.Length;
			DFA10_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA10_transition[i] = DFA.UnpackEncodedString(DFA10_transitionS[i]);
			}
		}

		public DFA10( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 10;
			this.eot = DFA10_eot;
			this.eof = DFA10_eof;
			this.min = DFA10_min;
			this.max = DFA10_max;
			this.accept = DFA10_accept;
			this.special = DFA10_special;
			this.transition = DFA10_transition;
		}

		public override string Description { get { return "()* loopback of 152:11: ( ( NEWLINE )+ stmt )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _NEWLINE_in_root283 = new BitSet(new ulong[]{0x40011000000UL});
		public static readonly BitSet _node_in_root287 = new BitSet(new ulong[]{0x40011000000UL});
		public static readonly BitSet _NEWLINE_in_root291 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _EOF_in_root294 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_def_in_node305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_type_name316 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_func_type_name328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_func_type_name334 = new BitSet(new ulong[]{0x40001000000UL});
		public static readonly BitSet _func_type_name_in_func_type_name336 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_func_type_name339 = new BitSet(new ulong[]{0x40001000000UL});
		public static readonly BitSet _func_type_name_in_func_type_name341 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_func_type_name344 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_generic_parameter364 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_generic_parameter367 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _IDENT_in_generic_parameter370 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _stmt_alloc_in_func_args383 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_func_args386 = new BitSet(new ulong[]{0x1000000UL,0x200UL});
		public static readonly BitSet _stmt_alloc_in_func_args388 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _func_type_name_in_func_def410 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _IDENT_in_func_def412 = new BitSet(new ulong[]{0x800040000000000UL});
		public static readonly BitSet _59_in_func_def415 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _generic_parameter_in_func_def417 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _65_in_func_def419 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_func_def423 = new BitSet(new ulong[]{0x80001000000UL,0x200UL});
		public static readonly BitSet _func_args_in_func_def425 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_func_def428 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _stmt_block_in_func_def430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INDENT_in_stmt_block444 = new BitSet(new ulong[]{0x10000020UL});
		public static readonly BitSet _NEWLINE_in_stmt_block447 = new BitSet(new ulong[]{0x11000000UL,0x300UL});
		public static readonly BitSet _stmt_in_stmt_block450 = new BitSet(new ulong[]{0x10000020UL});
		public static readonly BitSet _NEWLINE_in_stmt_block454 = new BitSet(new ulong[]{0x10000020UL});
		public static readonly BitSet _DEDENT_in_stmt_block457 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stmt_expr_in_stmt468 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stmt_alloc_in_stmt_expr479 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stmt_return_in_stmt_expr484 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _72_in_stmt_return495 = new BitSet(new ulong[]{0xCD51105000002UL,0x800UL});
		public static readonly BitSet _expr_in_stmt_return497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_name_in_stmt_alloc518 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _IDENT_in_stmt_alloc520 = new BitSet(new ulong[]{0x4000000000000002UL});
		public static readonly BitSet _62_in_stmt_alloc523 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _expr_in_stmt_alloc525 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _73_in_stmt_alloc545 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _IDENT_in_stmt_alloc547 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _73_in_stmt_alloc549 = new BitSet(new ulong[]{0x4000000000000002UL});
		public static readonly BitSet _62_in_stmt_alloc552 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _expr_in_stmt_alloc554 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lambda_expr_in_expr578 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_lambda_expr589 = new BitSet(new ulong[]{0x1000000UL,0x200UL});
		public static readonly BitSet _func_args_in_lambda_expr591 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_lambda_expr593 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_lambda_expr595 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _modify_expr_in_lambda_expr597 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modify_expr_in_lambda_expr612 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cond_expr_in_modify_expr673 = new BitSet(new ulong[]{0x5111228000000002UL,0x488UL});
		public static readonly BitSet _modify_expr_op_in_modify_expr682 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _cond_expr_in_modify_expr686 = new BitSet(new ulong[]{0x5111228000000002UL,0x488UL});
		public static readonly BitSet _cond_expr_in_cond_expr_item711 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cmp_expr_in_cond_expr723 = new BitSet(new ulong[]{0x2UL,0x10UL});
		public static readonly BitSet _68_in_cond_expr732 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _cond_expr_item_in_cond_expr736 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_cond_expr738 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _cond_expr_item_in_cond_expr742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _add_expr_in_cmp_expr801 = new BitSet(new ulong[]{0xA800002000000002UL,0x6UL});
		public static readonly BitSet _cmp_expr_op_in_cmp_expr810 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _add_expr_in_cmp_expr814 = new BitSet(new ulong[]{0xA800002000000002UL,0x6UL});
		public static readonly BitSet _mul_expr_in_add_expr844 = new BitSet(new ulong[]{0x4400000000002UL});
		public static readonly BitSet _46_in_add_expr854 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _mul_expr_in_add_expr858 = new BitSet(new ulong[]{0x4400000000002UL});
		public static readonly BitSet _50_in_add_expr883 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _mul_expr_in_add_expr887 = new BitSet(new ulong[]{0x4400000000002UL});
		public static readonly BitSet _prefix_expr_in_mul_expr925 = new BitSet(new ulong[]{0x80104000000002UL});
		public static readonly BitSet _44_in_mul_expr935 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _prefix_expr_in_mul_expr939 = new BitSet(new ulong[]{0x80104000000002UL});
		public static readonly BitSet _55_in_mul_expr967 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _prefix_expr_in_mul_expr971 = new BitSet(new ulong[]{0x80104000000002UL});
		public static readonly BitSet _38_in_mul_expr999 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _prefix_expr_in_mul_expr1003 = new BitSet(new ulong[]{0x80104000000002UL});
		public static readonly BitSet _prefix_expr_op_in_prefix_expr1077 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _prefix_expr_in_prefix_expr1079 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _suffix_expr_in_prefix_expr1095 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_expr_list1107 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_expr_list1110 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _expr_in_expr_list1113 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _atom_expr_in_suffix_expr1129 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _47_in_suffix_expr1139 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _51_in_suffix_expr1165 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _54_in_suffix_expr1188 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _IDENT_in_suffix_expr1190 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _53_in_suffix_expr1215 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _IDENT_in_suffix_expr1217 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _58_in_suffix_expr1242 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _IDENT_in_suffix_expr1244 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _42_in_suffix_expr1269 = new BitSet(new ulong[]{0xCDD1105000000UL,0x800UL});
		public static readonly BitSet _expr_list_in_suffix_expr1271 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_suffix_expr1274 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _69_in_suffix_expr1298 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _expr_in_suffix_expr1300 = new BitSet(new ulong[]{0x0UL,0x40UL});
		public static readonly BitSet _70_in_suffix_expr1302 = new BitSet(new ulong[]{0x468840000000002UL,0x20UL});
		public static readonly BitSet _INT_in_atom_expr1338 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_atom_expr1343 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_atom_expr1348 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_atom_expr1357 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _expr_in_atom_expr1359 = new BitSet(new ulong[]{0x2080000000000UL});
		public static readonly BitSet _49_in_atom_expr1362 = new BitSet(new ulong[]{0xCD51105000000UL,0x800UL});
		public static readonly BitSet _expr_in_atom_expr1364 = new BitSet(new ulong[]{0x2080000000000UL});
		public static readonly BitSet _43_in_atom_expr1371 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_lvalue1401 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  SugarCpp.Compiler 
