//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 SugarCpp.g 2013-04-19 15:25:52

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  SugarCpp.Compiler 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class SugarCppParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "Block", "DEDENT", "Func_Def", "INDENT", "INT", "Left_Round_Bracket", "NEWLINE", "Right_Round_Bracket", "Root", "SP", "Var", "WS"
	};
	public const int EOF=-1;
	public const int Block=4;
	public const int DEDENT=5;
	public const int Func_Def=6;
	public const int INDENT=7;
	public const int INT=8;
	public const int Left_Round_Bracket=9;
	public const int NEWLINE=10;
	public const int Right_Round_Bracket=11;
	public const int Root=12;
	public const int SP=13;
	public const int Var=14;
	public const int WS=15;

	public SugarCppParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SugarCppParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return SugarCppParser.tokenNames; } }
	public override string GrammarFileName { get { return "SugarCpp.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_root();
	partial void LeaveRule_root();

	// $ANTLR start "root"
	// SugarCpp.g:84:8: public root : ( func_def )+ EOF -> ^( Root ( func_def )+ ) ;
	[GrammarRule("root")]
	public AstParserRuleReturnScope<CommonTree, IToken> root()
	{
		EnterRule_root();
		EnterRule("root", 1);
		TraceIn("root", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_def1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EOF2_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_func_def=new RewriteRuleSubtreeStream(adaptor,"rule func_def");
		try { DebugEnterRule(GrammarFileName, "root");
		DebugLocation(84, 1);
		try
		{
			// SugarCpp.g:85:2: ( ( func_def )+ EOF -> ^( Root ( func_def )+ ) )
			DebugEnterAlt(1);
			// SugarCpp.g:85:4: ( func_def )+ EOF
			{
			DebugLocation(85, 4);
			// SugarCpp.g:85:4: ( func_def )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==Var))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:85:4: func_def
					{
					DebugLocation(85, 4);
					PushFollow(Follow._func_def_in_root138);
					func_def1=func_def();
					PopFollow();

					stream_func_def.Add(func_def1.Tree);

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(85, 14);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_root141);  
			stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: func_def
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 85:18: -> ^( Root ( func_def )+ )
			{
				DebugLocation(85, 21);
				// SugarCpp.g:85:21: ^( Root ( func_def )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(85, 23);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Root, "Root"), root_1);

				DebugLocation(85, 28);
				if (!(stream_func_def.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_func_def.HasNext )
				{
					DebugLocation(85, 28);
					adaptor.AddChild(root_1, stream_func_def.NextTree());

				}
				stream_func_def.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("root", 1);
			LeaveRule("root", 1);
			LeaveRule_root();
		}
		DebugLocation(86, 1);
		} finally { DebugExitRule(GrammarFileName, "root"); }
		return retval;

	}
	// $ANTLR end "root"

	partial void EnterRule_func_def();
	partial void LeaveRule_func_def();

	// $ANTLR start "func_def"
	// SugarCpp.g:88:1: func_def : Var stmt_block -> ^( Func_Def stmt_block ) ;
	[GrammarRule("func_def")]
	private AstParserRuleReturnScope<CommonTree, IToken> func_def()
	{
		EnterRule_func_def();
		EnterRule("func_def", 2);
		TraceIn("func_def", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken Var3 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> stmt_block4 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Var3_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Var=new RewriteRuleITokenStream(adaptor,"token Var");
		RewriteRuleSubtreeStream stream_stmt_block=new RewriteRuleSubtreeStream(adaptor,"rule stmt_block");
		try { DebugEnterRule(GrammarFileName, "func_def");
		DebugLocation(88, 4);
		try
		{
			// SugarCpp.g:89:2: ( Var stmt_block -> ^( Func_Def stmt_block ) )
			DebugEnterAlt(1);
			// SugarCpp.g:89:4: Var stmt_block
			{
			DebugLocation(89, 4);
			Var3=(IToken)Match(input,Var,Follow._Var_in_func_def161);  
			stream_Var.Add(Var3);

			DebugLocation(89, 8);
			PushFollow(Follow._stmt_block_in_func_def163);
			stmt_block4=stmt_block();
			PopFollow();

			stream_stmt_block.Add(stmt_block4.Tree);


			{
			// AST REWRITE
			// elements: stmt_block
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 89:19: -> ^( Func_Def stmt_block )
			{
				DebugLocation(89, 22);
				// SugarCpp.g:89:22: ^( Func_Def stmt_block )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(89, 24);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Func_Def, "Func_Def"), root_1);

				DebugLocation(89, 33);
				adaptor.AddChild(root_1, stream_stmt_block.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_def", 2);
			LeaveRule("func_def", 2);
			LeaveRule_func_def();
		}
		DebugLocation(90, 4);
		} finally { DebugExitRule(GrammarFileName, "func_def"); }
		return retval;

	}
	// $ANTLR end "func_def"

	partial void EnterRule_stmt_block();
	partial void LeaveRule_stmt_block();

	// $ANTLR start "stmt_block"
	// SugarCpp.g:92:1: stmt_block : INDENT ! ( stmt )+ DEDENT !;
	[GrammarRule("stmt_block")]
	private AstParserRuleReturnScope<CommonTree, IToken> stmt_block()
	{
		EnterRule_stmt_block();
		EnterRule("stmt_block", 3);
		TraceIn("stmt_block", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INDENT5 = default(IToken);
		IToken DEDENT7 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> stmt6 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INDENT5_tree = default(CommonTree);
		CommonTree DEDENT7_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "stmt_block");
		DebugLocation(92, 1);
		try
		{
			// SugarCpp.g:93:2: ( INDENT ! ( stmt )+ DEDENT !)
			DebugEnterAlt(1);
			// SugarCpp.g:93:4: INDENT ! ( stmt )+ DEDENT !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(93, 10);
			INDENT5=(IToken)Match(input,INDENT,Follow._INDENT_in_stmt_block185); 
			DebugLocation(93, 12);
			// SugarCpp.g:93:12: ( stmt )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if (((LA2_0>=INT && LA2_0<=Left_Round_Bracket)||LA2_0==Var))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// SugarCpp.g:93:12: stmt
					{
					DebugLocation(93, 12);
					PushFollow(Follow._stmt_in_stmt_block188);
					stmt6=stmt();
					PopFollow();

					adaptor.AddChild(root_0, stmt6.Tree);

					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(93, 24);
			DEDENT7=(IToken)Match(input,DEDENT,Follow._DEDENT_in_stmt_block191); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt_block", 3);
			LeaveRule("stmt_block", 3);
			LeaveRule_stmt_block();
		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt_block"); }
		return retval;

	}
	// $ANTLR end "stmt_block"

	partial void EnterRule_stmt();
	partial void LeaveRule_stmt();

	// $ANTLR start "stmt"
	// SugarCpp.g:96:1: stmt : ( INT | func_def | '(' ! stmt ')' !);
	[GrammarRule("stmt")]
	private AstParserRuleReturnScope<CommonTree, IToken> stmt()
	{
		EnterRule_stmt();
		EnterRule("stmt", 4);
		TraceIn("stmt", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT8 = default(IToken);
		IToken char_literal10 = default(IToken);
		IToken char_literal12 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> func_def9 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> stmt11 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT8_tree = default(CommonTree);
		CommonTree char_literal10_tree = default(CommonTree);
		CommonTree char_literal12_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "stmt");
		DebugLocation(96, 1);
		try
		{
			// SugarCpp.g:97:2: ( INT | func_def | '(' ! stmt ')' !)
			int alt3=3;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt3 = 1;
				}
				break;
			case Var:
				{
				alt3 = 2;
				}
				break;
			case Left_Round_Bracket:
				{
				alt3 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// SugarCpp.g:97:4: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(97, 4);
				INT8=(IToken)Match(input,INT,Follow._INT_in_stmt203); 
				INT8_tree = (CommonTree)adaptor.Create(INT8);
				adaptor.AddChild(root_0, INT8_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SugarCpp.g:98:4: func_def
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(98, 4);
				PushFollow(Follow._func_def_in_stmt208);
				func_def9=func_def();
				PopFollow();

				adaptor.AddChild(root_0, func_def9.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SugarCpp.g:99:4: '(' ! stmt ')' !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(99, 7);
				char_literal10=(IToken)Match(input,Left_Round_Bracket,Follow._Left_Round_Bracket_in_stmt213); 
				DebugLocation(99, 9);
				PushFollow(Follow._stmt_in_stmt216);
				stmt11=stmt();
				PopFollow();

				adaptor.AddChild(root_0, stmt11.Tree);
				DebugLocation(99, 17);
				char_literal12=(IToken)Match(input,Right_Round_Bracket,Follow._Right_Round_Bracket_in_stmt218); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stmt", 4);
			LeaveRule("stmt", 4);
			LeaveRule_stmt();
		}
		DebugLocation(100, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt"); }
		return retval;

	}
	// $ANTLR end "stmt"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _func_def_in_root138 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EOF_in_root141 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Var_in_func_def161 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _stmt_block_in_func_def163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INDENT_in_stmt_block185 = new BitSet(new ulong[]{0x4300UL});
		public static readonly BitSet _stmt_in_stmt_block188 = new BitSet(new ulong[]{0x4320UL});
		public static readonly BitSet _DEDENT_in_stmt_block191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_stmt203 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_def_in_stmt208 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Left_Round_Bracket_in_stmt213 = new BitSet(new ulong[]{0x4300UL});
		public static readonly BitSet _stmt_in_stmt216 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _Right_Round_Bracket_in_stmt218 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  SugarCpp.Compiler 
